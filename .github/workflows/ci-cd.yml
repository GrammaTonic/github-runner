name: CI/CD Pipeline
# Canonical branch flow for this repository:
# - Feature work: create feature branches from `develop` and open PRs targeting `develop` (feature -> develop).
# - Integration: merge feature PRs into `develop` and run integration/user-experience checks on those PRs.
# - Promotion: create a PR from `develop` -> `main` to promote integrated changes to production; CI also validates promotions.
#
# Jobs in this workflow are intentionally conservative:
# - Many jobs run on both `develop` and `main` pushes to keep staging and deployment paths intact.
# - Job-level `if:` guards that check `github.event.pull_request.base.ref` are updated to account for feature PRs targeting `develop` as well as promotion PRs from `develop`->`main`.
# Edit with care: updating triggers or branch checks may affect deployment or baseline seeding behavior.
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
      - "tests/**"
      - "docs/**"
  workflow_dispatch:
    inputs:
      skip_tests:
        description: "Skip testing steps"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Force rebuild Docker images (ignore cache)"
        required: false
        default: false
        type: boolean
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}
permissions:
  contents: read
  packages: write
  security-events: write
  pull-requests: write
  checks: write
  actions: read
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  IMAGE_CHROME_NAME: ${{ github.repository }}-chrome
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
jobs:
  provision-normal-runner:
    name: Provision Normal Runner
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Inject built normal runner image tag into docker-compose.production.yml
        env:
          NORMAL_IMAGE_TAG: ${{ needs.build.outputs.normal-image-primary }}
        run: |
          echo "Injecting built normal runner image tag into docker-compose.production.yml..."
          sed -i.bak "s|image: ghcr.io/grammatonic/github-runner:latest|image: $NORMAL_IMAGE_TAG|" docker/docker-compose.production.yml
          echo "Updated image line in docker-compose.production.yml to: $NORMAL_IMAGE_TAG"
      - name: Pull and verify built normal runner image
        env:
          NORMAL_IMAGE_TAG: ${{ needs.build.outputs.normal-image-primary }}
        run: |
          docker pull "$NORMAL_IMAGE_TAG"
          echo "Pulled normal runner image: $NORMAL_IMAGE_TAG"
      - name: Provision normal runner container in staging
        env:
          RUNNER_LABELS: staging,ci,self-hosted
          GITHUB_TOKEN: ${{ secrets.STAGING_GITHUB_TOKEN }}
        run: |
          echo "Provisioning normal runner container in staging..."
          echo "Using labels: $RUNNER_LABELS"
          echo "Injecting GITHUB_TOKEN from secrets.STAGING_GITHUB_TOKEN"
          docker compose -f docker/docker-compose.production.yml up -d
            echo "Checking if normal runner container is running..."
            if [ "$(docker ps -q -f name=github-runner-main)" ]; then
            echo "Normal runner container is running."
            else
            echo "Normal runner container is not running! Printing status and logs for diagnostics:"
            docker ps -a
            docker logs github-runner-main || echo "No logs available."
            exit 1
            fi
      - name: Health check normal runner container
        run: |
          echo "Checking health of normal runner container..."
          if ! docker ps -a --format '{{.Names}}' | grep -q '^github-runner-main$'; then
            echo "ERROR: github-runner-main container does not exist. Skipping health check."
            exit 1
          fi
          MAX_RETRIES=6
          RETRY_INTERVAL=5
          for i in $(seq 1 $MAX_RETRIES); do
            HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' github-runner-main)
            echo "Full health JSON: $HEALTH_JSON"
            STATUS=$(echo "$HEALTH_JSON" | jq -r '.Status')
            FAILING_STREAK=$(echo "$HEALTH_JSON" | jq -r '.FailingStreak')
            LOGS=$(echo "$HEALTH_JSON" | jq -r '.Log | @json')
            echo "Health status: $STATUS"
            echo "Failing streak: $FAILING_STREAK"
            echo "Health logs: $LOGS"
            if [ "$STATUS" = "healthy" ]; then
            echo "Normal runner container health is healthy."
            break
            elif [ "$STATUS" = "unhealthy" ]; then
            echo "ERROR: Normal runner container is unhealthy!"
            exit 1
            elif [ "$STATUS" = "starting" ]; then
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Health status is 'starting', waiting $RETRY_INTERVAL seconds before retry ($i/$MAX_RETRIES)..."
              sleep $RETRY_INTERVAL
            else
              echo "WARNING: Normal runner container health is still 'starting' after $MAX_RETRIES retries."
              exit 1
            fi
            else
            echo "Unknown health status: $STATUS"
            exit 1
            fi
          done
      - name: Check normal runner container for GitHub connection
        run: |
          echo "Checking normal runner container logs for GitHub connection..."
          if docker logs github-runner-main | grep -q "Connected to GitHub"; then
          echo "‚úÖ Normal runner successfully connected to GitHub."
          else
          echo "‚ùå Normal runner did NOT connect to GitHub. Printing logs for diagnostics:"
          docker logs github-runner-main
          exit 1
          fi
  provision-chrome-runner:
    name: Provision Chrome Runner For testing
    runs-on: ubuntu-latest
    needs: [build-chrome]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Inject built Chrome runner image tag into docker-compose.chrome.yml
        env:
          CHROME_IMAGE_TAG: ${{ needs.build-chrome.outputs.chrome-image-primary }}
        run: |
          echo "Injecting built Chrome runner image tag into docker-compose.chrome.yml..."
          sed -i.bak "s|image: ghcr.io/grammatonic/github-runner:chrome-latest|image: $CHROME_IMAGE_TAG|" docker/docker-compose.chrome.yml
          echo "Updated image line in docker-compose.chrome.yml to: $CHROME_IMAGE_TAG"
      - name: Pull and verify built Chrome runner image
        env:
          CHROME_IMAGE_TAG: ${{ needs.build-chrome.outputs.chrome-image-primary }}
        run: |
          docker pull "$CHROME_IMAGE_TAG"
          echo "Pulled Chrome runner image: $CHROME_IMAGE_TAG"
      - name: Provision Chrome runner container in staging
        env:
          RUNNER_LABELS: chrome,ui-tests,extra-label
          GITHUB_TOKEN: ${{ secrets.STAGING_GITHUB_TOKEN }}
        run: |
          echo "Provisioning Chrome runner container in staging..."
          echo "Using labels: $RUNNER_LABELS"
          echo "Injecting GITHUB_TOKEN from secrets.STAGING_GITHUB_TOKEN"
          docker compose -f docker/docker-compose.chrome.yml up -d
          echo "Checking if Chrome runner container is running..."
          RUNNING=$(docker ps --filter "name=github-runner-chrome" --filter "status=running" -q)
          if [ -z "$RUNNING" ]; then
            echo "ERROR: Chrome runner container is not running! Printing status and logs:"
            docker ps -a
            docker logs github-runner-chrome || echo "No logs available."
            exit 1
          else
            echo "Chrome runner container is running."
              echo "--- Chrome runner container logs (post-startup) ---"
              docker logs github-runner-chrome || echo "No logs available."
              echo "--- End of Chrome runner container logs ---"
          fi
      - name: Health check Chrome runner container
        run: |
            echo "Checking health of Chrome runner container..."
            MAX_RETRIES=6
            RETRY_INTERVAL=5
            for i in $(seq 1 $MAX_RETRIES); do
              HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' github-runner-chrome)
              echo "Full health JSON: $HEALTH_JSON"
              STATUS=$(echo "$HEALTH_JSON" | jq -r '.Status')
              FAILING_STREAK=$(echo "$HEALTH_JSON" | jq -r '.FailingStreak')
              LOGS=$(echo "$HEALTH_JSON" | jq -r '.Log | @json')
              echo "Health status: $STATUS"
              echo "Failing streak: $FAILING_STREAK"
              echo "Health logs: $LOGS"
              if [ "$STATUS" = "healthy" ]; then
                echo "Chrome runner container health is healthy."
                break
              elif [ "$STATUS" = "unhealthy" ]; then
                echo "ERROR: Chrome runner container is unhealthy!"
                exit 1
              elif [ "$STATUS" = "starting" ]; then
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "Health status is 'starting', waiting $RETRY_INTERVAL seconds before retry ($i/$MAX_RETRIES)..."
                  sleep $RETRY_INTERVAL
                else
                  echo "WARNING: Chrome runner container health is still 'starting' after $MAX_RETRIES retries."
                  exit 1
                fi
              else
                echo "Unknown health status: $STATUS"
                exit 1
              fi
            done
      - name: Check Chrome runner container for GitHub connection
        run: |
          echo "Checking Chrome runner container logs for GitHub connection..."
          if docker logs github-runner-chrome | grep -q "Connected to GitHub"; then
            echo "‚úÖ Chrome runner successfully connected to GitHub."
          else
            echo "‚ùå Chrome runner did NOT connect to GitHub. Printing logs for diagnostics:"
            docker logs github-runner-chrome
            exit 1
          fi
      - name: Run playwright screenshot test on Chrome runner
        run: |
          echo "Running Playwright screenshot integration script..."
          chmod +x tests/integration/playwright_screenshot_integration.sh
          tests/integration/playwright_screenshot_integration.sh
      - name: Upload Playwright screenshot artifact
        uses: actions/upload-artifact@v4
        with:
          name: playwright-google-screenshot
          path: test-results/playwright/google_screenshot_*.png
          retention-days: 30
  lint-and-validate:
    name: Lint and Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Validate Docker files
        run: |
          # Check if Docker files exist
          find . -name "Dockerfile*" -type f | while read -r dockerfile; do
            echo "Validating $dockerfile"
            # Run hadolint, ignore DL3002 for builder stages
            if ! docker run --rm -i hadolint/hadolint hadolint --ignore DL3002 --ignore DL3008 --ignore DL3015 --ignore DL3013 --ignore DL3016 --ignore DL3059 - < "$dockerfile"; then
              echo "Critical errors found in $dockerfile"
              exit 1
            fi
          done
      - name: Validate Docker Compose files
        run: |
          # Validate separate compose files syntax
          if [[ -f "docker/docker-compose.production.yml" ]]; then
            docker compose -f docker/docker-compose.production.yml config --quiet
          fi
          if [[ -f "docker/docker-compose.chrome.yml" ]]; then
            docker compose -f docker/docker-compose.chrome.yml config --quiet
          fi
      - name: Validate shell scripts
        run: |
          # Install shellcheck
          sudo apt-get update && sudo apt-get install -y shellcheck

          # Check all shell scripts (fail on errors and warnings for better quality)
          find . -name "*.sh" -type f | while read -r script; do
            echo "Checking $script"
            shellcheck -S warning "$script" || exit 1
          done
      - name: Check environment file templates
        run: |
          # Validate environment file syntax (basic check)
          find config/ -name "*.env*" -type f 2>/dev/null | while read -r envfile; do
            echo "Validating $envfile"
            # Check for basic syntax issues in env files
            grep -v '^#' "$envfile" | grep -v '^$' | grep -qE '^[A-Za-z_][A-Za-z0-9_]*=' || {
              echo "Warning: $envfile may have invalid environment variable syntax"
            }
          done || true
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Trivy vulnerability scanner on filesystem
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"
      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"
          category: "security-scan"
      - name: Check for secrets in repository
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.before }}
          head: HEAD
          extra_args: --debug --only-verified
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    permissions:
      contents: read
      packages: write
    outputs:
      normal-image-digest: ${{ steps.build.outputs.digest }}
      normal-image-tag: ${{ steps.meta.outputs.tags }}
      normal-image-primary: ${{ steps.get-primary-tag.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Extract normal runner metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=raw,value=latest,branch=main
      - name: Build and push normal runner Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          file: ./docker/Dockerfile
          push: true
          load: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha
            type=gha,scope=normal-runner
          cache-to: type=gha,mode=max,scope=normal-runner
          no-cache: ${{ github.event.inputs.force_rebuild == 'true' }}
      - name: Get primary normal runner tag for security scan
        id: get-primary-tag
        if: success() && steps.build.conclusion == 'success'
        run: |
          TAGS="${{ steps.meta.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary normal runner tag for security scan: $PRIMARY_TAG"
          echo "Normal runner image pushed to registry: $PRIMARY_TAG"
          echo "$PRIMARY_TAG" > build-normal-image-tag.txt
          echo "${{ steps.build.outputs.digest }}" > build-normal-image-digest.txt
      - name: Upload normal runner build image tag as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-normal-image-tag
          path: build-normal-image-tag.txt
          retention-days: 30
      - name: Upload normal runner build image digest as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-normal-image-digest
          path: build-normal-image-digest.txt
          retention-days: 30
  build-chrome:
    name: Build Chrome Runner Image
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    permissions:
      contents: read
      packages: write
    outputs:
      chrome-image-digest: ${{ steps.build-chrome.outputs.digest }}
      chrome-image-tag: ${{ steps.meta-chrome.outputs.tags }}
      chrome-image-primary: ${{ steps.get-primary-tag-chrome.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Extract Chrome runner metadata
        id: meta-chrome
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_CHROME_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=raw,value=latest,branch=main
          labels: |
            org.opencontainers.image.name=github-runner-chrome
      - name: Build and push Chrome runner image
        id: build-chrome
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          file: ./docker/Dockerfile.chrome
          push: true
          load: false
          tags: ${{ steps.meta-chrome.outputs.tags }}
          labels: ${{ steps.meta-chrome.outputs.labels }}
          cache-from: |
            type=gha
            type=gha,scope=chrome-runner
          cache-to: type=gha,mode=max,scope=chrome-runner
          no-cache: ${{ github.event.inputs.force_rebuild == 'true' }}
      - name: Get primary Chrome runner tag for security scan
        id: get-primary-tag-chrome
        if: success() && steps.build-chrome.conclusion == 'success'
        run: |
          TAGS="${{ steps.meta-chrome.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary Chrome runner tag for security scan: $PRIMARY_TAG"
          echo "Chrome runner image pushed to registry: $PRIMARY_TAG"
          echo "$PRIMARY_TAG" > build-chrome-image-tag.txt
          echo "${{ steps.build-chrome.outputs.digest }}" > build-chrome-image-digest.txt
      - name: Upload Chrome build image tag as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-chrome-image-tag
          path: build-chrome-image-tag.txt
          retention-days: 30
      - name: Upload Chrome build image digest as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-chrome-image-digest
          path: build-chrome-image-digest.txt
          retention-days: 30
  # Comprehensive Testing Suite
  test-package-validation:
    name: Package Validation Tests
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Run Package Validation Tests
        run: |
          echo "üß™ Running comprehensive package validation tests..."
          # Make scripts executable
          chmod +x tests/docker/validate-packages.sh
          chmod +x tests/unit/package-validation.sh
          # Run package validation in dry-run mode first (syntax check)
          echo "Running package validation (dry-run)..."
          DRY_RUN=true tests/docker/validate-packages.sh
          # Run unit tests for package detection
          echo "Running unit tests for obsolete package detection..."
          tests/unit/package-validation.sh
      - name: Upload package validation results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: package-validation-results
          path: test-results/
          retention-days: 30
  test-comprehensive:
    name: Comprehensive Integration Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          [unit, integration, docker-validation, security, configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Set up test environment
        run: |
          # Install comprehensive test dependencies
          sudo apt-get update
          sudo apt-get install -y jq curl
          # Install hadolint for Docker linting (from GitHub releases)
          HADOLINT_VERSION="v2.12.0"
          wget -O /tmp/hadolint "https://github.com/hadolint/hadolint/releases/download/${HADOLINT_VERSION}/hadolint-Linux-x86_64"
          chmod +x /tmp/hadolint
          sudo mv /tmp/hadolint /usr/local/bin/hadolint
          # Verify hadolint installation
          hadolint --version || echo "Hadolint installation failed, will skip Docker linting"
          # Create test results directory
          mkdir -p test-results/${{ matrix.test-suite }}
          # Make all test scripts executable
          find tests/ -name "*.sh" -type f -exec chmod +x {} \;
      - name: Run Unit Tests
        if: matrix.test-suite == 'unit'
        run: |
          echo "üß™ Running unit tests..."
          # Run unit tests for package validation
          TEST_RESULTS_DIR="test-results/unit" tests/unit/package-validation.sh
      - name: Run Integration Tests
        if: matrix.test-suite == 'integration'
        run: |
          echo "üß™ Running integration tests..."
          # Create integration test results directory
          mkdir -p test-results/integration
          # Run focused integration tests for CI environment
          # Skip Docker builds and container tests (tested separately)
          integration_errors=0
          # Test 1: Dockerfile syntax validation
          echo "Validating Dockerfile syntax..."
          if command -v hadolint >/dev/null 2>&1; then
            for dockerfile in docker/Dockerfile*; do
              if [[ -f "$dockerfile" ]]; then
                dockerfile_name="$(basename "$dockerfile")"
                # Run hadolint with informational and warning level issues only (ignore style issues)
                if hadolint --ignore DL3008 --ignore DL3009 --ignore DL3015 "$dockerfile" > "test-results/integration/hadolint-$dockerfile_name.log" 2>&1; then
                  echo "‚úÖ Hadolint passed for $dockerfile"
                else
                  echo "‚ö†Ô∏è  Hadolint found issues in $dockerfile (see log for details)"
                  # Don't fail the build for hadolint issues, just warn
                fi
              fi
            done
          else
            echo "‚ÑπÔ∏è  Hadolint not available, skipping Docker linting"
          fi
          # Test 2: Docker Compose validation
          echo "Validating docker-compose files..."
          # Create temporary directories that compose files expect to exist
          mkdir -p ../cache/build ../cache/deps ../cache/workspace ../config
          mkdir -p docker/test-reports
          for compose_file in docker/docker-compose*.yml; do
            if [[ -f "$compose_file" ]]; then
              compose_name="$(basename "$compose_file")"
              # Set dummy environment variables to avoid warnings during validation
              if GITHUB_TOKEN=dummy GITHUB_REPOSITORY=dummy/repo docker compose -f "$compose_file" config > "test-results/integration/compose-$compose_name.log" 2>&1; then
                echo "‚úÖ Docker Compose validation passed for $compose_file"
              else
                echo "‚ùå Docker Compose validation failed for $compose_file"
                echo "Error details:" 
                cat "test-results/integration/compose-$compose_name.log" | head -20
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done
          # Clean up temporary directories
          rmdir ../cache/build ../cache/deps ../cache/workspace 2>/dev/null || true
          rmdir ../cache 2>/dev/null || true
          rmdir docker/test-reports 2>/dev/null || true
          # Test 3: Configuration file validation
          echo "Validating configuration files..."
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              if [[ "$config_name" != "*.env" ]] && [[ "$config_name" == *.env* ]]; then
                echo "Checking $config_name format..."
                if ! grep -q "=" "$config_file"; then
                  echo "‚ùå Configuration file $config_name appears to be empty or invalid"
                  integration_errors=$((integration_errors + 1))
                fi
              fi
            fi
          done
          # Test 4: Script validation
          echo "Validating shell scripts..."
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              if ! bash -n "$script" > "test-results/integration/syntax-$script_name.log" 2>&1; then
                echo "‚ùå Syntax error in $script"
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done
          echo "Integration tests completed. Errors: $integration_errors"
          if [[ $integration_errors -gt 0 ]]; then
            echo "‚ùå Integration tests failed"
            exit 1
          else
            echo "‚úÖ Integration tests passed"
          fi
      - name: Run Docker Package Validation
        if: matrix.test-suite == 'docker-validation'
        run: |
          echo "üß™ Running Docker package validation..."
          # Create docker validation test results directory
          mkdir -p test-results/docker-validation
          # Run focused Docker package validation (without building)
          docker_errors=0
          # Test 1: Package duplication check
          echo "Checking for duplicate packages in Dockerfiles..."
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              # Extract package names from RUN commands that install packages
              packages=$(grep -E "RUN.*apt-get install|RUN.*apk add" "$dockerfile" | \
                sed -E 's/.*apt-get install[^a-zA-Z-]*//; s/.*apk add[^a-zA-Z-]*//; s/[\\&|;].*//; s/#.*//; s/\s+/ /g' | \
                tr ' ' '\n' | grep -E '^[a-zA-Z][a-zA-Z0-9.-]*$' | sort)
              # Check for duplicates
              duplicates=$(echo "$packages" | uniq -d)
              if [[ -n "$duplicates" ]]; then
                echo "‚ùå Duplicate packages found in $dockerfile_name:"
                echo "$duplicates"
                echo "$duplicates" > "test-results/docker-validation/duplicates-$dockerfile_name.log"
                docker_errors=$((docker_errors + 1))
              else
                echo "‚úÖ No duplicates in $dockerfile_name"
              fi
            fi
          done
          # Test 2: Obsolete package check
          echo "Checking for known obsolete packages..."
          obsolete_packages=("python2" "python2.7" "python-pip" "nodejs-legacy")
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              for pkg in "${obsolete_packages[@]}"; do
                if grep -q "$pkg" "$dockerfile"; then
                  echo "‚ùå Obsolete package '$pkg' found in $dockerfile_name"
                  echo "$pkg" >> "test-results/docker-validation/obsolete-$dockerfile_name.log"
                  docker_errors=$((docker_errors + 1))
                fi
              done
            fi
          done
          echo "Docker validation completed. Errors: $docker_errors"
          if [[ $docker_errors -gt 0 ]]; then
            echo "‚ùå Docker package validation failed"
            exit 1
          else
            echo "‚úÖ Docker package validation passed"
          fi
      - name: Run Security Tests
        if: matrix.test-suite == 'security'
        run: |
          echo "üß™ Running security validation tests..."
          # Create security test results directory
          mkdir -p test-results/security
          # Check for potential secrets
          echo "Checking for potential secrets..."
          secret_patterns=("password" "secret" "token" "key" "api_key" "auth")
          secrets_found=false
          for pattern in "${secret_patterns[@]}"; do
            if grep -r -i "$pattern" . \
                --exclude-dir=".git" \
                --exclude-dir="test-results" \
                --exclude-dir="logs" \
                --exclude="*.log" \
                --exclude="*.md" \
                | grep -v "# Example\|TODO\|FIXME\|template\|placeholder\|test.*$pattern" > "test-results/security/secrets-$pattern.log" 2>&1; then
              echo "‚ö†Ô∏è  Potential secrets pattern '$pattern' found"
              secrets_found=true
            fi
          done
          # Check Docker security practices
          echo "Checking Docker security practices..."
          security_issues=0
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              # Check for running as root
              if ! grep -q "USER " "$dockerfile"; then
                echo "SECURITY: $dockerfile_name may run as root" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
              # Check for COPY . .
              if grep -q "COPY \. \." "$dockerfile"; then
                echo "SECURITY: $dockerfile_name uses 'COPY . .' - overly broad" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
            fi
          done
          echo "Security scan completed. Issues found: $security_issues"
      - name: Run Configuration Tests
        if: matrix.test-suite == 'configuration'
        run: |
          echo "üß™ Running configuration validation tests..."
          # Create configuration test results directory
          mkdir -p test-results/configuration
          config_errors=0
          # Test configuration files
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              echo "Validating $config_name..."
              # Syntax check
              if ! bash -n "$config_file" > "test-results/configuration/$config_name.log" 2>&1; then
                echo "‚ùå Syntax error in $config_name"
                config_errors=$((config_errors + 1))
              fi
              # Check for required variables
              required_vars=("GITHUB_TOKEN" "GITHUB_REPOSITORY")
              for var in "${required_vars[@]}"; do
                if ! grep -q "^$var\|^#.*$var" "$config_file"; then
                  echo "MISSING: $var not found in $config_name" >> "test-results/configuration/missing-vars.log"
                fi
              done
            fi
          done
          # Test scripts
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              # Syntax check
              if ! bash -n "$script" > "test-results/configuration/$script_name.log" 2>&1; then
                echo "‚ùå Syntax error in $script_name"
                config_errors=$((config_errors + 1))
              fi
            fi
          done
          echo "Configuration validation completed. Errors found: $config_errors"
          if [[ $config_errors -gt 0 ]]; then
            exit 1
          fi
      - name: Upload comprehensive test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-suite }}
          path: test-results/${{ matrix.test-suite }}
          retention-days: 30
  test-user-deployment:
    name: User Deployment Experience Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    # Run on either:
    #  - Feature PRs targeting 'develop' (feature -> develop), so we validate user deployment experience early
    #  - Promotion PRs from 'develop' into 'main' (develop -> main), so we validate release promotions
    if: ${{ github.event_name == 'pull_request' && (github.event.pull_request.base.ref == 'develop' || (github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.ref == 'develop')) }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Pull built images from registry
        run: |
          # Pull the images that were just built and pushed by the build jobs
          echo "Pulling main runner image: ${{ needs.build.outputs.normal-image-primary }}"
          docker pull "${{ needs.build.outputs.normal-image-primary }}"
          echo "Pulling Chrome runner image: ${{ needs.build-chrome.outputs.chrome-image-primary }}"
          docker pull "${{ needs.build-chrome.outputs.chrome-image-primary }}"
          # Tag for easier testing
          docker tag "${{ needs.build.outputs.normal-image-primary }}" github-runner:latest
          docker tag "${{ needs.build-chrome.outputs.chrome-image-primary }}" github-runner:chrome-latest
          echo "Available images for testing:"
          docker images | grep github-runner
      - name: Run User Deployment Experience Tests
        run: |
          chmod +x tests/user-deployment/test-user-experience.sh
          tests/user-deployment/test-user-experience.sh
      - name: Upload user deployment test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: user-deployment-test-results
          path: test-results/user-deployment
          retention-days: 30
  test-container-startup:
    name: Container Startup Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        container-type: [main-runner, chrome-runner]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Download built images
        run: |
          # Log in to Container Registry to pull the built images
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
      - name: Pull and verify Docker images
        run: |
          # Pull the built Docker images from the registry instead of using artifacts
          if [[ "${{ matrix.container-type }}" == "main-runner" ]]; then
            IMAGE_TAG="${{ needs.build.outputs.normal-image-primary }}"
            echo "Pulling main runner image: $IMAGE_TAG"
            docker pull "$IMAGE_TAG"
            # Tag for easier testing
            docker tag "$IMAGE_TAG" github-runner:latest
            echo "Tagged as github-runner:latest"
          else
            IMAGE_TAG="${{ needs.build-chrome.outputs.chrome-image-primary }}"
            echo "Pulling Chrome runner image: $IMAGE_TAG"
            docker pull "$IMAGE_TAG"
            # Tag for easier testing  
            docker tag "$IMAGE_TAG" github-runner:chrome-latest
            echo "Tagged as github-runner:chrome-latest"
          fi
          # Verify images are available
          echo "Available Docker images:"
          docker images | grep github-runner
      - name: Set up container test environment
        run: |
          # Create test results directory
          mkdir -p test-results/container-startup/${{ matrix.container-type }}
          # Use the actual user environment template and production Docker Compose
          # This tests the real user experience, not custom CI configurations
          # Copy the user environment template
          cp config/runner.env.example config/runner.env
          # Configure with valid test values that won't cause GitHub API calls
          sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=ghp_test_token_for_ci_not_real/' config/runner.env
          sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=test-org\/test-repository/' config/runner.env
          sed -i 's/RUNNER_NAME=.*/RUNNER_NAME=ci-test-main-runner/' config/runner.env
          sed -i 's/RUNNER_LABELS=.*/RUNNER_LABELS=test,ci,docker,self-hosted/' config/runner.env
          # Verify the user environment file is properly configured
          echo "=== User Environment Configuration ==="
          grep -E '^[A-Z_]+=.*' config/runner.env | head -10
          echo "=== End Configuration ==="
      - name: Test Main Runner Container Startup
        if: matrix.container-type == 'main-runner'
        run: |
          echo "üöÄ Testing main GitHub runner using production Docker Compose..."
          # Test using the actual production Docker Compose file that users would use
          # This validates the real user experience, not custom CI configurations
          # Create test override to bypass GitHub registration for CI and use the built image
          IMAGE_TAG="${{ needs.build.outputs.normal-image-primary }}"
          cat > docker/docker-compose.test-override.yml << EOF
          services:
            github-runner:
              image: ${IMAGE_TAG}
              environment:
                # Override environment to prevent GitHub API calls
                - GITHUB_TOKEN=ghp_test_token_for_ci_not_real
                - GITHUB_REPOSITORY=test-org/test-repository
                - RUNNER_NAME=ci-test-main-runner
                - RUNNER_LABELS=test,ci,docker,self-hosted
                - RUNNER_TEST_MODE=true
              entrypoint: |
                bash -c '
                echo "=== Production Container Startup Test ==="
                echo "Testing container using production Docker Compose configuration..."
                # Basic system checks that validate the production setup
                echo "‚úì Container started with production configuration"
                echo "‚úì User context: $$(whoami)"
                echo "‚úì Working directory: $$(pwd)"
                echo "‚úì Environment variables loaded:"
                echo "  - GITHUB_TOKEN: $$(echo $$GITHUB_TOKEN | cut -c1-10)..."
                echo "  - GITHUB_REPOSITORY: $$GITHUB_REPOSITORY"
                echo "  - RUNNER_NAME: $$RUNNER_NAME"
                echo "  - RUNNER_LABELS: $$RUNNER_LABELS"
                # Test tools that production runners need
                echo "‚úì Git available: $$(git --version)"
                echo "‚úì Docker available: $$(docker --version)"
                echo "‚úì Node.js available: $$(node --version)"
                echo "‚úì Python available: $$(python3 --version)"
                # Validate production container setup
                echo "‚úì Production environment validation completed"
                echo "=== Test completed successfully ==="
                exit 0
                '
          EOF
          # Start container using production Docker Compose with test override (run one-shot container)
          echo "Running test container..."
          docker compose -f docker/docker-compose.production.yml -f docker/docker-compose.test-override.yml run --rm github-runner
          # Get container logs from the completed run
          echo "=== Production Container Test Results ==="
          echo "Container completed successfully"
          # Verify Docker Compose configuration
          echo "üìä Verifying production Docker Compose configuration..."
          if ! grep -q "restart:" docker/docker-compose.production.yml; then
            echo "‚ö†Ô∏è No restart policy configured in docker-compose.production.yml"
          else
            echo "‚úÖ Restart policy configured"
          fi
          if grep -q "healthcheck:" docker/docker-compose.production.yml; then
            echo "‚úÖ Health check configured"
          else
            echo "üí° Consider adding health checks for production readiness"
          fi
          echo "‚úÖ Production main runner container startup test passed"
          # Cleanup
          docker compose -f docker/docker-compose.production.yml down || true
      - name: Test Chrome Runner Container Startup
        if: matrix.container-type == 'chrome-runner'
        run: |
          echo "üöÄ Testing Chrome GitHub runner using production Docker Compose..."
          # Test using the actual production Docker Compose file that users would use
          # This validates the real user experience for Chrome runners
          # Update environment for Chrome-specific settings
          sed -i 's/RUNNER_NAME=.*/RUNNER_NAME=ci-test-chrome-runner/' config/runner.env
          sed -i 's/RUNNER_LABELS=.*/RUNNER_LABELS=chrome,ui-tests,selenium,playwright,cypress,headless/' config/runner.env
          # Create Chrome test override to bypass GitHub registration for CI and use the built image
          CHROME_IMAGE_TAG="${{ needs.build-chrome.outputs.chrome-image-primary }}"
          cat > docker/docker-compose.chrome-test-override.yml << EOF
          services:
            github-runner-chrome:
              image: ${CHROME_IMAGE_TAG}
              environment:
                # Override environment to prevent GitHub API calls
                - GITHUB_TOKEN=ghp_test_token_for_ci_not_real
                - GITHUB_REPOSITORY=test-org/test-repository
                - RUNNER_NAME=ci-test-chrome-runner
                - RUNNER_LABELS=chrome,ui-tests,selenium,playwright,cypress,headless
                - RUNNER_TEST_MODE=true
                - DISPLAY=:99
                - CHROME_FLAGS=--headless --no-sandbox --disable-dev-shm-usage --disable-gpu
              entrypoint: |
                bash -c '
                echo "=== Production Chrome Container Startup Test ==="
                echo "Testing Chrome container using production Docker Compose configuration..."
                # Basic system checks for Chrome production setup
                echo "‚úì Chrome container started with production configuration"
                echo "‚úì User context: $$(whoami)"
                echo "‚úì Working directory: $$(pwd)"
                echo "‚úì Environment variables loaded:"
                echo "  - GITHUB_TOKEN: $$(echo $$GITHUB_TOKEN | cut -c1-10)..."
                echo "  - GITHUB_REPOSITORY: $$GITHUB_REPOSITORY"
                echo "  - RUNNER_NAME: $$RUNNER_NAME"
                echo "  - RUNNER_LABELS: $$RUNNER_LABELS"
                # Test Chrome-specific tools that production runners need
                echo "Testing Chrome installation..."
                if command -v google-chrome >/dev/null 2>&1; then
                  echo "‚úì Chrome available: $$(google-chrome --version)"
                else
                  echo "‚ùå Chrome not found"
                  exit 1
                fi
                # Test ChromeDriver
                if command -v chromedriver >/dev/null 2>&1; then
                  echo "‚úì ChromeDriver available: $$(chromedriver --version)"
                else
                  echo "‚ùå ChromeDriver not found"
                  exit 1
                fi
                # Test development tools
                echo "‚úì Node.js available: $$(node --version)"
                echo "‚úì npm available: $$(npm --version)"
                echo "‚úì Python available: $$(python3 --version)"
                # Test Chrome headless functionality
                echo "Testing Chrome headless functionality..."
                if timeout 30 google-chrome --headless --no-sandbox --disable-dev-shm-usage --virtual-time-budget=1000 --dump-dom about:blank > /tmp/chrome-test.html 2>/dev/null; then
                    printf "\u2713 Chrome headless test passed\n"
                else
                  printf "\u26a0\ufe0f Chrome headless test warning (may work in different environment)\n"
                  printf "\u26a0\ufe0f Check /tmp/chrome-test.html for details. Consider increasing resources or updating Chrome.\n"
                fi
                echo "‚úì Production Chrome environment validation completed"
                echo "=== Test completed successfully ==="
                exit 0
                '
          EOF
          # Start Chrome container using Chrome compose with test override (run one-shot container)
          echo "Running Chrome test container..."
          docker compose -f docker/docker-compose.chrome.yml -f docker/docker-compose.chrome-test-override.yml run --rm github-runner-chrome
          # Test completed successfully if we reach here
          echo "=== Production Chrome Container Test Results ==="
          echo "Chrome container completed successfully"
          # Verify Chrome Docker Compose configuration
          echo "üìä Verifying Chrome Docker Compose configuration..."
          if ! grep -q "restart:" docker/docker-compose.chrome.yml; then
            echo "‚ö†Ô∏è No restart policy configured in docker-compose.chrome.yml"
          else
            echo "‚úÖ Restart policy configured"
          fi
          if grep -q "healthcheck:" docker/docker-compose.chrome.yml; then
            echo "‚úÖ Health check configured"
          else
            echo "üí° Consider adding health checks for production readiness"
          fi
          echo "‚úÖ Production Chrome runner container startup test passed"
          # Cleanup
          docker compose -f docker/docker-compose.chrome.yml down || true
      - name: Generate container startup report
        if: always()
        run: |
          # Create detailed startup test report
          REPORT_DIR="test-results/container-startup/${{ matrix.container-type }}"
          mkdir -p "$REPORT_DIR"
          echo "# Container Startup Test Report" > "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"
          echo "## Test Details" >> "$REPORT_DIR/startup-report.md"
          echo "- **Container Type**: ${{ matrix.container-type }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Test Date**: $(date -Iseconds)" >> "$REPORT_DIR/startup-report.md"
          echo "- **Workflow**: ${{ github.workflow }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Run ID**: ${{ github.run_id }}" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"
          # Add Docker info
          echo "## Docker Environment" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker version >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"
          # Add image info
          echo "## Image Information" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker images | grep github-runner >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
      - name: Upload container startup test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: container-startup-results-${{ matrix.container-type }}
          path: test-results/container-startup/${{ matrix.container-type }}
          retention-days: 30
  security-container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Run Trivy vulnerability scanner on container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.normal-image-primary }}
          format: "sarif"
          output: "trivy-container-results.sarif"
      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-container-results.sarif"
          category: "container-scan"
  security-chrome-scan:
    name: Chrome Container Security Scan
    runs-on: ubuntu-latest
    needs: [build-chrome]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Run Trivy vulnerability scanner on Chrome container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-chrome.outputs.chrome-image-primary }}
          format: "sarif"
          output: "trivy-chrome-results.sarif"
      - name: Upload Chrome container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-chrome-results.sarif"
          category: "chrome-container-scan"
  cleanup:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    needs:
      - provision-normal-runner
      - provision-chrome-runner
      - security-container-scan
      - security-chrome-scan
      - test-container-startup
      - test-comprehensive
    if: always()
    permissions:
      contents: read
      packages: write
    steps:
      - name: Clean up old container images
        run: |
          echo "Cleaning up old container images..."
          # In a real scenario, this would clean up old images from the registry
          # For example, keeping only the last 10 images
          echo "Cleanup completed"
      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."
          # Create deployment summary line by line
          echo "# Deployment Report" > deployment-report.md
          echo "" >> deployment-report.md
          echo "## Summary" >> deployment-report.md
          echo "- **Workflow Run ID**: ${{ github.run_id }}" >> deployment-report.md
          echo "- **Commit SHA**: ${{ github.sha }}" >> deployment-report.md
          echo "- **Branch**: ${{ github.ref_name }}" >> deployment-report.md
          echo "- **Triggered by**: ${{ github.actor }}" >> deployment-report.md
          echo "- **Timestamp**: $(date -u)" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Image Details" >> deployment-report.md
          echo "- Registry: ${{ env.REGISTRY }}" >> deployment-report.md
          echo "- Repository: ${{ env.IMAGE_NAME }}" >> deployment-report.md
          echo "- Tags: Built and scanned successfully" >> deployment-report.md
          # Check if file was created
          if [[ ! -f deployment-report.md ]]; then
            echo "ERROR: deployment-report.md not created"
            exit 1
          fi
          cat deployment-report.md
      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: deployment-report.md
          retention-days: 90
