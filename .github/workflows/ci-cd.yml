name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    # Run on all pushes to main/develop (including merges)
    # No path filters to ensure merge events always trigger CI/CD
    tags: ["v*.*.*"] # Tags trigger regardless of paths
  pull_request:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
      - "tests/**"
      - "docs/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment for deployment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: "Skip testing steps"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Force rebuild Docker images (ignore cache)"
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

permissions:
  contents: read
  packages: write
  security-events: write
  pull-requests: write
  checks: write
  actions: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  lint-and-validate:
    name: Lint and Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate Docker files
        run: |
          # Check if Docker files exist
          find . -name "Dockerfile*" -type f | while read -r dockerfile; do
            echo "Validating $dockerfile"
            # Run hadolint but only fail on errors, not warnings
            if ! docker run --rm -i hadolint/hadolint hadolint --ignore DL3008 --ignore DL3015 --ignore DL3013 --ignore DL3016 --ignore DL3059 - < "$dockerfile"; then
              echo "Critical errors found in $dockerfile"
              exit 1
            fi
          done

      - name: Validate Docker Compose files
        run: |
          # Validate separate compose files syntax
          if [[ -f "docker/docker-compose.production.yml" ]]; then
            docker compose -f docker/docker-compose.production.yml config --quiet
          fi
          if [[ -f "docker/docker-compose.chrome.yml" ]]; then
            docker compose -f docker/docker-compose.chrome.yml config --quiet
          fi

      - name: Validate shell scripts
        run: |
          # Install shellcheck
          sudo apt-get update && sudo apt-get install -y shellcheck

          # Check all shell scripts (fail on errors and warnings for better quality)
          find . -name "*.sh" -type f | while read -r script; do
            echo "Checking $script"
            shellcheck -S warning "$script" || exit 1
          done

      - name: Check environment file templates
        run: |
          # Validate environment file syntax (basic check)
          find config/ -name "*.env*" -type f 2>/dev/null | while read -r envfile; do
            echo "Validating $envfile"
            # Check for basic syntax issues in env files
            grep -v '^#' "$envfile" | grep -v '^$' | grep -qE '^[A-Za-z_][A-Za-z0-9_]*=' || {
              echo "Warning: $envfile may have invalid environment variable syntax"
            }
          done || true

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner on filesystem
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Check for secrets in repository
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.before }}
          head: HEAD
          extra_args: --debug --only-verified

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
      image-primary: ${{ steps.get-primary-tag.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix=sha-,enable={{is_default_branch}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          file: ./docker/Dockerfile
          push: true
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ false }}

      - name: Get primary tag for security scan
        id: get-primary-tag
        if: success() && steps.build.conclusion == 'success'
        run: |
          # Extract the first tag from the multi-line tags output for security scanning
          TAGS="${{ steps.meta.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary tag for security scan: $PRIMARY_TAG"
          echo "Image pushed to registry: $PRIMARY_TAG"

  build-chrome:
    name: Build Chrome Runner Image
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build-chrome.outputs.digest }}
      image-tag: ${{ steps.meta-chrome.outputs.tags }}
      image-primary: ${{ steps.get-primary-tag-chrome.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Chrome runner metadata
        id: meta-chrome
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,suffix=-chrome
            type=ref,event=pr,suffix=-chrome
            type=ref,event=tag,suffix=-chrome
            type=semver,pattern={{version}}-chrome
            type=semver,pattern={{major}}.{{minor}}-chrome
            type=semver,pattern={{major}}-chrome
            type=sha,prefix=sha-,suffix=-chrome,enable={{is_default_branch}}
            type=raw,value=chrome-latest,enable={{is_default_branch}}

      - name: Build and push Chrome runner image
        id: build-chrome
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          file: ./docker/Dockerfile.chrome
          push: true
          load: true
          tags: ${{ steps.meta-chrome.outputs.tags }}
          labels: ${{ steps.meta-chrome.outputs.labels }}
          cache-from: type=gha,scope=chrome
          cache-to: type=gha,mode=max,scope=chrome
          no-cache: ${{ false }}

      - name: Get primary Chrome tag for security scan
        id: get-primary-tag-chrome
        if: success() && steps.build-chrome.conclusion == 'success'
        run: |
          # Extract the first tag from the multi-line tags output for security scanning
          TAGS="${{ steps.meta-chrome.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary Chrome tag for security scan: $PRIMARY_TAG"
          echo "Chrome image pushed to registry: $PRIMARY_TAG"

  # Comprehensive Testing Suite
  test-package-validation:
    name: Package Validation Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Package Validation Tests
        run: |
          echo "ðŸ§ª Running comprehensive package validation tests..."

          # Make scripts executable
          chmod +x tests/docker/validate-packages.sh
          chmod +x tests/unit/package-validation.sh

          # Run package validation in dry-run mode first (syntax check)
          echo "Running package validation (dry-run)..."
          DRY_RUN=true tests/docker/validate-packages.sh

          # Run unit tests for package detection
          echo "Running unit tests for obsolete package detection..."
          tests/unit/package-validation.sh

      - name: Upload package validation results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: package-validation-results
          path: test-results/
          retention-days: 30

  test-comprehensive:
    name: Comprehensive Integration Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          [unit, integration, docker-validation, security, configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up test environment
        run: |
          # Install comprehensive test dependencies
          sudo apt-get update
          sudo apt-get install -y jq curl

          # Install hadolint for Docker linting (from GitHub releases)
          HADOLINT_VERSION="v2.12.0"
          wget -O /tmp/hadolint "https://github.com/hadolint/hadolint/releases/download/${HADOLINT_VERSION}/hadolint-Linux-x86_64"
          chmod +x /tmp/hadolint
          sudo mv /tmp/hadolint /usr/local/bin/hadolint

          # Verify hadolint installation
          hadolint --version || echo "Hadolint installation failed, will skip Docker linting"

          # Create test results directory
          mkdir -p test-results/${{ matrix.test-suite }}

          # Make all test scripts executable
          find tests/ -name "*.sh" -type f -exec chmod +x {} \;

      - name: Run Unit Tests
        if: matrix.test-suite == 'unit'
        run: |
          echo "ðŸ§ª Running unit tests..."

          # Run unit tests for package validation
          TEST_RESULTS_DIR="test-results/unit" tests/unit/package-validation.sh

      - name: Run Integration Tests
        if: matrix.test-suite == 'integration'
        run: |
          echo "ðŸ§ª Running integration tests..."

          # Create integration test results directory
          mkdir -p test-results/integration

          # Run focused integration tests for CI environment
          # Skip Docker builds and container tests (tested separately)

          integration_errors=0

          # Test 1: Dockerfile syntax validation
          echo "Validating Dockerfile syntax..."
          if command -v hadolint >/dev/null 2>&1; then
            for dockerfile in docker/Dockerfile*; do
              if [[ -f "$dockerfile" ]]; then
                dockerfile_name="$(basename "$dockerfile")"
                # Run hadolint with informational and warning level issues only (ignore style issues)
                if hadolint --ignore DL3008 --ignore DL3009 --ignore DL3015 "$dockerfile" > "test-results/integration/hadolint-$dockerfile_name.log" 2>&1; then
                  echo "âœ… Hadolint passed for $dockerfile"
                else
                  echo "âš ï¸  Hadolint found issues in $dockerfile (see log for details)"
                  # Don't fail the build for hadolint issues, just warn
                fi
              fi
            done
          else
            echo "â„¹ï¸  Hadolint not available, skipping Docker linting"
          fi

          # Test 2: Docker Compose validation
          echo "Validating docker-compose files..."

          # Create temporary directories that compose files expect to exist
          mkdir -p ../cache/build ../cache/deps ../cache/workspace ../config
          mkdir -p docker/test-reports

          for compose_file in docker/docker-compose*.yml; do
            if [[ -f "$compose_file" ]]; then
              compose_name="$(basename "$compose_file")"
              # Set dummy environment variables to avoid warnings during validation
              if GITHUB_TOKEN=dummy GITHUB_REPOSITORY=dummy/repo docker compose -f "$compose_file" config > "test-results/integration/compose-$compose_name.log" 2>&1; then
                echo "âœ… Docker Compose validation passed for $compose_file"
              else
                echo "âŒ Docker Compose validation failed for $compose_file"
                echo "Error details:" 
                cat "test-results/integration/compose-$compose_name.log" | head -20
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done

          # Clean up temporary directories
          rmdir ../cache/build ../cache/deps ../cache/workspace 2>/dev/null || true
          rmdir ../cache 2>/dev/null || true
          rmdir docker/test-reports 2>/dev/null || true

          # Test 3: Configuration file validation
          echo "Validating configuration files..."
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              if [[ "$config_name" != "*.env" ]] && [[ "$config_name" == *.env* ]]; then
                echo "Checking $config_name format..."
                if ! grep -q "=" "$config_file"; then
                  echo "âŒ Configuration file $config_name appears to be empty or invalid"
                  integration_errors=$((integration_errors + 1))
                fi
              fi
            fi
          done

          # Test 4: Script validation
          echo "Validating shell scripts..."
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              if ! bash -n "$script" > "test-results/integration/syntax-$script_name.log" 2>&1; then
                echo "âŒ Syntax error in $script"
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done

          echo "Integration tests completed. Errors: $integration_errors"

          if [[ $integration_errors -gt 0 ]]; then
            echo "âŒ Integration tests failed"
            exit 1
          else
            echo "âœ… Integration tests passed"
          fi

      - name: Run Docker Package Validation
        if: matrix.test-suite == 'docker-validation'
        run: |
          echo "ðŸ§ª Running Docker package validation..."

          # Create docker validation test results directory
          mkdir -p test-results/docker-validation

          # Run focused Docker package validation (without building)
          docker_errors=0

          # Test 1: Package duplication check
          echo "Checking for duplicate packages in Dockerfiles..."
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              
              # Extract package names from RUN commands that install packages
              packages=$(grep -E "RUN.*apt-get install|RUN.*apk add" "$dockerfile" | \
                sed -E 's/.*apt-get install[^a-zA-Z-]*//; s/.*apk add[^a-zA-Z-]*//; s/[\\&|;].*//; s/#.*//; s/\s+/ /g' | \
                tr ' ' '\n' | grep -E '^[a-zA-Z][a-zA-Z0-9.-]*$' | sort)
              
              # Check for duplicates
              duplicates=$(echo "$packages" | uniq -d)
              if [[ -n "$duplicates" ]]; then
                echo "âŒ Duplicate packages found in $dockerfile_name:"
                echo "$duplicates"
                echo "$duplicates" > "test-results/docker-validation/duplicates-$dockerfile_name.log"
                docker_errors=$((docker_errors + 1))
              else
                echo "âœ… No duplicates in $dockerfile_name"
              fi
            fi
          done

          # Test 2: Obsolete package check
          echo "Checking for known obsolete packages..."
          obsolete_packages=("python2" "python2.7" "python-pip" "nodejs-legacy")
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              for pkg in "${obsolete_packages[@]}"; do
                if grep -q "$pkg" "$dockerfile"; then
                  echo "âŒ Obsolete package '$pkg' found in $dockerfile_name"
                  echo "$pkg" >> "test-results/docker-validation/obsolete-$dockerfile_name.log"
                  docker_errors=$((docker_errors + 1))
                fi
              done
            fi
          done

          echo "Docker validation completed. Errors: $docker_errors"

          if [[ $docker_errors -gt 0 ]]; then
            echo "âŒ Docker package validation failed"
            exit 1
          else
            echo "âœ… Docker package validation passed"
          fi

      - name: Run Security Tests
        if: matrix.test-suite == 'security'
        run: |
          echo "ðŸ§ª Running security validation tests..."

          # Create security test results directory
          mkdir -p test-results/security

          # Check for potential secrets
          echo "Checking for potential secrets..."
          secret_patterns=("password" "secret" "token" "key" "api_key" "auth")
          secrets_found=false

          for pattern in "${secret_patterns[@]}"; do
            if grep -r -i "$pattern" . \
                --exclude-dir=".git" \
                --exclude-dir="test-results" \
                --exclude-dir="logs" \
                --exclude="*.log" \
                --exclude="*.md" \
                | grep -v "# Example\|TODO\|FIXME\|template\|placeholder\|test.*$pattern" > "test-results/security/secrets-$pattern.log" 2>&1; then
              echo "âš ï¸  Potential secrets pattern '$pattern' found"
              secrets_found=true
            fi
          done

          # Check Docker security practices
          echo "Checking Docker security practices..."
          security_issues=0

          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              
              # Check for running as root
              if ! grep -q "USER " "$dockerfile"; then
                echo "SECURITY: $dockerfile_name may run as root" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
              
              # Check for COPY . .
              if grep -q "COPY \. \." "$dockerfile"; then
                echo "SECURITY: $dockerfile_name uses 'COPY . .' - overly broad" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
            fi
          done

          echo "Security scan completed. Issues found: $security_issues"

      - name: Run Configuration Tests
        if: matrix.test-suite == 'configuration'
        run: |
          echo "ðŸ§ª Running configuration validation tests..."

          # Create configuration test results directory
          mkdir -p test-results/configuration

          config_errors=0

          # Test configuration files
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              
              echo "Validating $config_name..."
              
              # Syntax check
              if ! bash -n "$config_file" > "test-results/configuration/$config_name.log" 2>&1; then
                echo "âŒ Syntax error in $config_name"
                config_errors=$((config_errors + 1))
              fi
              
              # Check for required variables
              required_vars=("GITHUB_TOKEN" "GITHUB_REPOSITORY")
              for var in "${required_vars[@]}"; do
                if ! grep -q "^$var\|^#.*$var" "$config_file"; then
                  echo "MISSING: $var not found in $config_name" >> "test-results/configuration/missing-vars.log"
                fi
              done
            fi
          done

          # Test scripts
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              
              # Syntax check
              if ! bash -n "$script" > "test-results/configuration/$script_name.log" 2>&1; then
                echo "âŒ Syntax error in $script_name"
                config_errors=$((config_errors + 1))
              fi
            fi
          done

          echo "Configuration validation completed. Errors found: $config_errors"

          if [[ $config_errors -gt 0 ]]; then
            exit 1
          fi

      - name: Upload comprehensive test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-suite }}
          path: test-results/${{ matrix.test-suite }}
          retention-days: 30

  test-user-deployment:
    name: User Deployment Experience Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.ref == 'develop'  }}
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built images from registry
        run: |
          # Pull the images that were just built and pushed by the build jobs
          echo "Pulling main runner image: ${{ needs.build.outputs.image-primary }}"
          docker pull "${{ needs.build.outputs.image-primary }}"

          echo "Pulling Chrome runner image: ${{ needs.build-chrome.outputs.image-primary }}"
          docker pull "${{ needs.build-chrome.outputs.image-primary }}"

          # Tag for easier testing
          docker tag "${{ needs.build.outputs.image-primary }}" github-runner:latest
          docker tag "${{ needs.build-chrome.outputs.image-primary }}" github-runner:chrome-latest

          echo "Available images for testing:"
          docker images | grep github-runner

      - name: Run User Deployment Experience Tests
        run: |
          chmod +x tests/user-deployment/test-user-experience.sh
          tests/user-deployment/test-user-experience.sh

      - name: Upload user deployment test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: user-deployment-test-results
          path: test-results/user-deployment
          retention-days: 30

  test-container-startup:
    name: Container Startup Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        container-type: [main-runner, chrome-runner]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Download built images
        run: |
          # Log in to Container Registry to pull the built images
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Pull and verify Docker images
        run: |
          # Pull the built Docker images from the registry instead of using artifacts
          if [[ "${{ matrix.container-type }}" == "main-runner" ]]; then
            IMAGE_TAG="${{ needs.build.outputs.image-primary }}"
            echo "Pulling main runner image: $IMAGE_TAG"
            docker pull "$IMAGE_TAG"
            
            # Tag for easier testing
            docker tag "$IMAGE_TAG" github-runner:latest
            echo "Tagged as github-runner:latest"
          else
            IMAGE_TAG="${{ needs.build-chrome.outputs.image-primary }}"
            echo "Pulling Chrome runner image: $IMAGE_TAG"
            docker pull "$IMAGE_TAG"
            
            # Tag for easier testing  
            docker tag "$IMAGE_TAG" github-runner:chrome-latest
            echo "Tagged as github-runner:chrome-latest"
          fi

          # Verify images are available
          echo "Available Docker images:"
          docker images | grep github-runner

      - name: Set up container test environment
        run: |
          # Create test results directory
          mkdir -p test-results/container-startup/${{ matrix.container-type }}

          # Use the actual user environment template and production Docker Compose
          # This tests the real user experience, not custom CI configurations

          # Copy the user environment template
          cp config/runner.env.example config/runner.env

          # Configure with valid test values that won't cause GitHub API calls
          sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=ghp_test_token_for_ci_not_real/' config/runner.env
          sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=test-org\/test-repository/' config/runner.env
          sed -i 's/RUNNER_NAME=.*/RUNNER_NAME=ci-test-main-runner/' config/runner.env
          sed -i 's/RUNNER_LABELS=.*/RUNNER_LABELS=test,ci,docker,self-hosted/' config/runner.env

          # Verify the user environment file is properly configured
          echo "=== User Environment Configuration ==="
          grep -E '^[A-Z_]+=.*' config/runner.env | head -10
          echo "=== End Configuration ==="

      - name: Test Main Runner Container Startup
        if: matrix.container-type == 'main-runner'
        run: |
          echo "ðŸš€ Testing main GitHub runner using production Docker Compose..."

          # Test using the actual production Docker Compose file that users would use
          # This validates the real user experience, not custom CI configurations

          # Create test override to bypass GitHub registration for CI and use the built image
          IMAGE_TAG="${{ needs.build.outputs.image-primary }}"
          cat > docker/docker-compose.test-override.yml << EOF
          services:
            github-runner:
              image: ${IMAGE_TAG}
              environment:
                # Override environment to prevent GitHub API calls
                - GITHUB_TOKEN=ghp_test_token_for_ci_not_real
                - GITHUB_REPOSITORY=test-org/test-repository
                - RUNNER_NAME=ci-test-main-runner
                - RUNNER_LABELS=test,ci,docker,self-hosted
                - RUNNER_TEST_MODE=true
              entrypoint: |
                bash -c '
                echo "=== Production Container Startup Test ==="
                echo "Testing container using production Docker Compose configuration..."
                
                # Basic system checks that validate the production setup
                echo "âœ“ Container started with production configuration"
                echo "âœ“ User context: $$(whoami)"
                echo "âœ“ Working directory: $$(pwd)"
                echo "âœ“ Environment variables loaded:"
                echo "  - GITHUB_TOKEN: $$(echo $$GITHUB_TOKEN | cut -c1-10)..."
                echo "  - GITHUB_REPOSITORY: $$GITHUB_REPOSITORY"
                echo "  - RUNNER_NAME: $$RUNNER_NAME"
                echo "  - RUNNER_LABELS: $$RUNNER_LABELS"
                
                # Test tools that production runners need
                echo "âœ“ Git available: $$(git --version)"
                echo "âœ“ Docker available: $$(docker --version)"
                echo "âœ“ Node.js available: $$(node --version)"
                echo "âœ“ Python available: $$(python3 --version)"
                
                # Validate production container setup
                echo "âœ“ Production environment validation completed"
                echo "=== Test completed successfully ==="
                exit 0
                '
          EOF

          # Start container using production compose with test override (run one-shot container)
          echo "Running test container..."
          docker compose -f docker/docker-compose.production.yml -f docker/docker-compose.test-override.yml run --rm github-runner

          # Get container logs from the completed run
          echo "=== Production Container Test Results ==="
          echo "Container completed successfully"

          # Verify Docker Compose configuration
          echo "ðŸ“Š Verifying production Docker Compose configuration..."
          if ! grep -q "restart:" docker/docker-compose.production.yml; then
            echo "âš ï¸ No restart policy configured in docker-compose.production.yml"
          else
            echo "âœ… Restart policy configured"
          fi

          if grep -q "healthcheck:" docker/docker-compose.production.yml; then
            echo "âœ… Health check configured"
          else
            echo "ðŸ’¡ Consider adding health checks for production readiness"
          fi
          echo "âœ… Production main runner container startup test passed"

          # Cleanup
          docker compose -f docker/docker-compose.production.yml down || true

      - name: Test Chrome Runner Container Startup
        if: matrix.container-type == 'chrome-runner'
        run: |
          echo "ðŸš€ Testing Chrome GitHub runner using production Docker Compose..."

          # Test using the actual production Docker Compose file that users would use
          # This validates the real user experience for Chrome runners

          # Update environment for Chrome-specific settings
          sed -i 's/RUNNER_NAME=.*/RUNNER_NAME=ci-test-chrome-runner/' config/runner.env
          sed -i 's/RUNNER_LABELS=.*/RUNNER_LABELS=chrome,ui-tests,selenium,playwright,cypress,headless/' config/runner.env

          # Create Chrome test override to bypass GitHub registration for CI and use the built image
          CHROME_IMAGE_TAG="${{ needs.build-chrome.outputs.image-primary }}"
          cat > docker/docker-compose.chrome-test-override.yml << EOF
          services:
            github-runner-chrome:
              image: ${CHROME_IMAGE_TAG}
              environment:
                # Override environment to prevent GitHub API calls
                - GITHUB_TOKEN=ghp_test_token_for_ci_not_real
                - GITHUB_REPOSITORY=test-org/test-repository
                - RUNNER_NAME=ci-test-chrome-runner
                - RUNNER_LABELS=chrome,ui-tests,selenium,playwright,cypress,headless
                - RUNNER_TEST_MODE=true
                - DISPLAY=:99
                - CHROME_FLAGS=--headless --no-sandbox --disable-dev-shm-usage --disable-gpu
              entrypoint: |
                bash -c '
                echo "=== Production Chrome Container Startup Test ==="
                echo "Testing Chrome container using production Docker Compose configuration..."
                
                # Basic system checks for Chrome production setup
                echo "âœ“ Chrome container started with production configuration"
                echo "âœ“ User context: $$(whoami)"
                echo "âœ“ Working directory: $$(pwd)"
                echo "âœ“ Environment variables loaded:"
                echo "  - GITHUB_TOKEN: $$(echo $$GITHUB_TOKEN | cut -c1-10)..."
                echo "  - GITHUB_REPOSITORY: $$GITHUB_REPOSITORY"
                echo "  - RUNNER_NAME: $$RUNNER_NAME"
                echo "  - RUNNER_LABELS: $$RUNNER_LABELS"
                
                # Test Chrome-specific tools that production runners need
                echo "Testing Chrome installation..."
                if command -v google-chrome >/dev/null 2>&1; then
                  echo "âœ“ Chrome available: $$(google-chrome --version)"
                else
                  echo "âŒ Chrome not found"
                  exit 1
                fi
                
                # Test ChromeDriver
                if command -v chromedriver >/dev/null 2>&1; then
                  echo "âœ“ ChromeDriver available: $$(chromedriver --version)"
                else
                  echo "âŒ ChromeDriver not found"
                  exit 1
                fi
                
                # Test development tools
                echo "âœ“ Node.js available: $$(node --version)"
                echo "âœ“ npm available: $$(npm --version)"
                echo "âœ“ Python available: $$(python3 --version)"
                
                # Test Chrome headless functionality
                echo "Testing Chrome headless functionality..."
                if timeout 30 google-chrome --headless --no-sandbox --disable-dev-shm-usage --virtual-time-budget=1000 --dump-dom about:blank > /tmp/chrome-test.html 2>/dev/null; then
                  echo "
                  echo "\u2713 Chrome headless test passed"
                else
                  printf "\u26a0\ufe0f Chrome headless test warning (may work in different environment)\n"
                  printf "\u26a0\ufe0f Check /tmp/chrome-test.html for details. Consider increasing resources or updating Chrome.\n"
                fi
                
                echo "âœ“ Production Chrome environment validation completed"
                echo "=== Test completed successfully ==="
                exit 0
                '
          EOF

          # Start Chrome container using Chrome compose with test override (run one-shot container)
          echo "Running Chrome test container..."
          docker compose -f docker/docker-compose.chrome.yml -f docker/docker-compose.chrome-test-override.yml run --rm github-runner-chrome

          # Test completed successfully if we reach here
          echo "=== Production Chrome Container Test Results ==="
          echo "Chrome container completed successfully"

          # Verify Chrome Docker Compose configuration
          echo "ðŸ“Š Verifying Chrome Docker Compose configuration..."
          if ! grep -q "restart:" docker/docker-compose.chrome.yml; then
            echo "âš ï¸ No restart policy configured in docker-compose.chrome.yml"
          else
            echo "âœ… Restart policy configured"
          fi

          if grep -q "healthcheck:" docker/docker-compose.chrome.yml; then
            echo "âœ… Health check configured"
          else
            echo "ðŸ’¡ Consider adding health checks for production readiness"
          fi
          echo "âœ… Production Chrome runner container startup test passed"

          # Cleanup
          docker compose -f docker/docker-compose.chrome.yml down || true

      - name: Generate container startup report
        if: always()
        run: |
          # Create detailed startup test report
          REPORT_DIR="test-results/container-startup/${{ matrix.container-type }}"
          mkdir -p "$REPORT_DIR"

          echo "# Container Startup Test Report" > "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"
          echo "## Test Details" >> "$REPORT_DIR/startup-report.md"
          echo "- **Container Type**: ${{ matrix.container-type }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Test Date**: $(date -Iseconds)" >> "$REPORT_DIR/startup-report.md"
          echo "- **Workflow**: ${{ github.workflow }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Run ID**: ${{ github.run_id }}" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"

          # Add Docker info
          echo "## Docker Environment" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker version >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"

          # Add image info
          echo "## Image Information" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker images | grep github-runner >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"

      - name: Upload container startup test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: container-startup-results-${{ matrix.container-type }}
          path: test-results/container-startup/${{ matrix.container-type }}
          retention-days: 30

  security-container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Trivy vulnerability scanner on container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image-primary }}
          format: "sarif"
          output: "trivy-container-results.sarif"

      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-container-results.sarif"

  security-chrome-scan:
    name: Chrome Container Security Scan
    runs-on: ubuntu-latest
    needs: [build-chrome]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Trivy vulnerability scanner on Chrome container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-chrome.outputs.image-primary }}
          format: "sarif"
          output: "trivy-chrome-results.sarif"

      - name: Upload Chrome container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-chrome-results.sarif"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs:
      [
        build,
        build-chrome,
        test-package-validation,
        test-comprehensive,
        test-container-startup,
        security-container-scan,
        security-chrome-scan,
      ]
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging-runners.example.com
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up staging environment
        run: |
          echo "Setting up staging deployment..."

          # Create staging directories
          mkdir -p staging-deploy

          # Copy deployment files
          cp -r docker/ staging-deploy/
          cp -r config/ staging-deploy/
          cp -r scripts/ staging-deploy/

      - name: Configure staging environment
        env:
          STAGING_GITHUB_TOKEN: ${{ secrets.STAGING_GITHUB_TOKEN }}
          STAGING_REPOSITORY: ${{ secrets.STAGING_REPOSITORY }}
        run: |
          cd staging-deploy

          # Update configuration for staging
          if [[ -f "config/runner.env" ]]; then
            sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=${{ secrets.STAGING_GITHUB_TOKEN }}/' config/runner.env
            sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=${{ secrets.STAGING_REPOSITORY }}/' config/runner.env
          fi

      - name: Deploy to staging
        run: |
          cd staging-deploy

          echo "Deploying to staging environment..."
          echo "Image: ${{ needs.build.outputs.image-tag }}"

          # In a real scenario, this would deploy to your staging infrastructure
          # For example: kubectl apply, docker stack deploy, etc.

          # Simulate deployment
          echo "Deployment completed successfully"

      - name: Run staging smoke tests
        run: |
          echo "Running smoke tests against staging..."

          # Add staging-specific health checks
          sleep 10

          # Simulate health check
          echo "Staging environment is healthy"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs:
      [
        build,
        build-chrome,
        test-package-validation,
        test-comprehensive,
        test-container-startup,
        security-container-scan,
        security-chrome-scan,
        deploy-staging,
      ]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')
    environment:
      name: production
      url: https://runners.example.com
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up production environment
        run: |
          echo "Setting up production deployment..."

          # Create production directories
          mkdir -p production-deploy

          # Copy deployment files
          cp -r docker/ production-deploy/
          cp -r config/ production-deploy/
          cp -r scripts/ production-deploy/

      - name: Configure production environment
        env:
          PROD_GITHUB_TOKEN: ${{ secrets.PROD_GITHUB_TOKEN }}
          PROD_REPOSITORY: ${{ secrets.PROD_REPOSITORY }}
        run: |
          cd production-deploy

          # Update configuration for production
          if [[ -f "config/runner.env" ]]; then
            sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=${{ secrets.PROD_GITHUB_TOKEN }}/' config/runner.env
            sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=${{ secrets.PROD_REPOSITORY }}/' config/runner.env
          fi

      - name: Deploy to production
        run: |
          cd production-deploy

          echo "Deploying to production environment..."
          echo "Image: ${{ needs.build.outputs.image-tag }}"

          # In a real scenario, this would deploy to your production infrastructure
          # For example: kubectl apply, docker stack deploy, etc.

          # Simulate deployment with blue/green strategy
          echo "Starting blue/green deployment..."
          echo "Production deployment completed successfully"

      - name: Run production health checks
        run: |
          echo "Running production health checks..."

          # Add production-specific health checks
          sleep 15

          # Simulate comprehensive health check
          echo "Production environment is healthy and ready"

      - name: Post-deployment monitoring setup
        run: |
          echo "Setting up post-deployment monitoring..."

          # In a real scenario, this would configure monitoring, alerts, etc.
          echo "Monitoring configured for production deployment"

  cleanup:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-production.result == 'failure')
    permissions:
      contents: read
      packages: write
    steps:
      - name: Clean up old container images
        run: |
          echo "Cleaning up old container images..."

          # In a real scenario, this would clean up old images from the registry
          # For example, keeping only the last 10 images
          echo "Cleanup completed"

      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."

          # Create deployment summary
          cat > deployment-report.md << 'EOF'
          # Deployment Report

          ## Summary
          - **Workflow Run ID**: ${{ github.run_id }}
          - **Commit SHA**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          - **Triggered by**: ${{ github.actor }}
          - **Timestamp**: $(date -u)

          ## Deployments
          - Production: ${{ needs.deploy-production.result }}

          ## Image Details
          - Registry: ${{ env.REGISTRY }}
          - Repository: ${{ env.IMAGE_NAME }}
          - Tags: Built and deployed successfully
          EOF

          cat deployment-report.md

      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: deployment-report.md
          retention-days: 90
