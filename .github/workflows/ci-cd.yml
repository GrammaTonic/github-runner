name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
    tags: ["v*.*.*"] # Tags trigger regardless of paths
  pull_request:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment for deployment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: "Skip testing steps"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Force rebuild Docker images (ignore cache)"
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

permissions:
  contents: read
  packages: write
  security-events: write
  pull-requests: write
  checks: write
  actions: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  lint-and-validate:
    name: Lint and Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate Docker files
        run: |
          # Check if Docker files exist
          find . -name "Dockerfile*" -type f | while read -r dockerfile; do
            echo "Validating $dockerfile"
            # Run hadolint but only fail on errors, not warnings
            if ! docker run --rm -i hadolint/hadolint hadolint --ignore DL3008 --ignore DL3015 --ignore DL3013 --ignore DL3016 --ignore DL3059 - < "$dockerfile"; then
              echo "Critical errors found in $dockerfile"
              exit 1
            fi
          done

      - name: Validate Docker Compose files
        run: |
          # Validate docker-compose.yml syntax
          if [[ -f "docker/docker-compose.yml" ]]; then
            docker compose -f docker/docker-compose.yml config --quiet
          fi

      - name: Validate shell scripts
        run: |
          # Install shellcheck
          sudo apt-get update && sudo apt-get install -y shellcheck

          # Check all shell scripts (fail on errors and warnings for better quality)
          find . -name "*.sh" -type f | while read -r script; do
            echo "Checking $script"
            shellcheck -S warning "$script" || exit 1
          done

      - name: Check environment file templates
        run: |
          # Validate environment file syntax (basic check)
          find config/ -name "*.env*" -type f 2>/dev/null | while read -r envfile; do
            echo "Validating $envfile"
            # Check for basic syntax issues in env files
            grep -v '^#' "$envfile" | grep -v '^$' | grep -qE '^[A-Za-z_][A-Za-z0-9_]*=' || {
              echo "Warning: $envfile may have invalid environment variable syntax"
            }
          done || true

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner on filesystem
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results.sarif"

      - name: Check for secrets in repository
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.before }}
          head: HEAD
          extra_args: --debug --only-verified

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
      image-primary: ${{ steps.get-primary-tag.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix=sha-,enable={{is_default_branch}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ inputs.force_rebuild || false }}

      - name: Get primary tag for security scan
        id: get-primary-tag
        run: |
          # Extract the first tag from the multi-line tags output for security scanning
          TAGS="${{ steps.meta.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary tag for security scan: $PRIMARY_TAG"

  build-chrome:
    name: Build Chrome Runner Image
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build-chrome.outputs.digest }}
      image-tag: ${{ steps.meta-chrome.outputs.tags }}
      image-primary: ${{ steps.get-primary-tag-chrome.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Chrome runner metadata
        id: meta-chrome
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,suffix=-chrome
            type=ref,event=pr,suffix=-chrome
            type=ref,event=tag,suffix=-chrome
            type=semver,pattern={{version}}-chrome
            type=semver,pattern={{major}}.{{minor}}-chrome
            type=semver,pattern={{major}}-chrome
            type=sha,prefix=sha-,suffix=-chrome,enable={{is_default_branch}}
            type=raw,value=chrome-latest,enable={{is_default_branch}}

      - name: Build and push Chrome runner image
        id: build-chrome
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          file: ./docker/Dockerfile.chrome
          push: true
          tags: ${{ steps.meta-chrome.outputs.tags }}
          labels: ${{ steps.meta-chrome.outputs.labels }}
          cache-from: type=gha,scope=chrome
          cache-to: type=gha,mode=max,scope=chrome
          no-cache: ${{ inputs.force_rebuild || false }}

      - name: Get primary Chrome tag for security scan
        id: get-primary-tag-chrome
        run: |
          # Extract the first tag from the multi-line tags output for security scanning
          TAGS="${{ steps.meta-chrome.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary Chrome tag for security scan: $PRIMARY_TAG"

  # Comprehensive Testing Suite
  test-package-validation:
    name: Package Validation Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Package Validation Tests
        run: |
          echo "🧪 Running comprehensive package validation tests..."

          # Make scripts executable
          chmod +x tests/docker/validate-packages.sh
          chmod +x tests/unit/package-validation.sh

          # Run package validation in dry-run mode first (syntax check)
          echo "Running package validation (dry-run)..."
          DRY_RUN=true tests/docker/validate-packages.sh

          # Run unit tests for package detection
          echo "Running unit tests for obsolete package detection..."
          tests/unit/package-validation.sh

      - name: Upload package validation results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: package-validation-results
          path: test-results/
          retention-days: 30

  test-comprehensive:
    name: Comprehensive Integration Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          [unit, integration, docker-validation, security, configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up test environment
        run: |
          # Install comprehensive test dependencies
          sudo apt-get update
          sudo apt-get install -y jq curl hadolint

          # Create test results directory
          mkdir -p test-results/${{ matrix.test-suite }}

          # Make all test scripts executable
          find tests/ -name "*.sh" -type f -exec chmod +x {} \;

      - name: Run Unit Tests
        if: matrix.test-suite == 'unit'
        run: |
          echo "🧪 Running unit tests..."

          # Run unit tests for package validation
          TEST_RESULTS_DIR="test-results/unit" tests/unit/package-validation.sh

      - name: Run Integration Tests
        if: matrix.test-suite == 'integration'
        run: |
          echo "🧪 Running integration tests..."

          # Run comprehensive integration tests
          TEST_RESULTS_DIR="test-results/integration" tests/integration/comprehensive-tests.sh

      - name: Run Docker Package Validation
        if: matrix.test-suite == 'docker-validation'
        run: |
          echo "🧪 Running Docker package validation..."

          # Run package validation against actual repositories
          TEST_RESULTS_DIR="test-results/docker" tests/docker/validate-packages.sh

      - name: Run Security Tests
        if: matrix.test-suite == 'security'
        run: |
          echo "🧪 Running security validation tests..."

          # Create security test results directory
          mkdir -p test-results/security

          # Check for potential secrets
          echo "Checking for potential secrets..."
          secret_patterns=("password" "secret" "token" "key" "api_key" "auth")
          secrets_found=false

          for pattern in "${secret_patterns[@]}"; do
            if grep -r -i "$pattern" . \
                --exclude-dir=".git" \
                --exclude-dir="test-results" \
                --exclude-dir="logs" \
                --exclude="*.log" \
                --exclude="*.md" \
                | grep -v "# Example\|TODO\|FIXME\|template\|placeholder\|test.*$pattern" > "test-results/security/secrets-$pattern.log" 2>&1; then
              echo "⚠️  Potential secrets pattern '$pattern' found"
              secrets_found=true
            fi
          done

          # Check Docker security practices
          echo "Checking Docker security practices..."
          security_issues=0

          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              
              # Check for running as root
              if ! grep -q "USER " "$dockerfile"; then
                echo "SECURITY: $dockerfile_name may run as root" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
              
              # Check for COPY . .
              if grep -q "COPY \. \." "$dockerfile"; then
                echo "SECURITY: $dockerfile_name uses 'COPY . .' - overly broad" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
            fi
          done

          echo "Security scan completed. Issues found: $security_issues"

      - name: Run Configuration Tests
        if: matrix.test-suite == 'configuration'
        run: |
          echo "🧪 Running configuration validation tests..."

          # Create configuration test results directory
          mkdir -p test-results/configuration

          config_errors=0

          # Test configuration files
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              
              echo "Validating $config_name..."
              
              # Syntax check
              if ! bash -n "$config_file" > "test-results/configuration/$config_name.log" 2>&1; then
                echo "❌ Syntax error in $config_name"
                config_errors=$((config_errors + 1))
              fi
              
              # Check for required variables
              required_vars=("GITHUB_TOKEN" "GITHUB_REPOSITORY")
              for var in "${required_vars[@]}"; do
                if ! grep -q "^$var\|^#.*$var" "$config_file"; then
                  echo "MISSING: $var not found in $config_name" >> "test-results/configuration/missing-vars.log"
                fi
              done
            fi
          done

          # Test scripts
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              
              # Syntax check
              if ! bash -n "$script" > "test-results/configuration/$script_name.log" 2>&1; then
                echo "❌ Syntax error in $script_name"
                config_errors=$((config_errors + 1))
              fi
            fi
          done

          echo "Configuration validation completed. Errors found: $config_errors"

          if [[ $config_errors -gt 0 ]]; then
            exit 1
          fi

      - name: Upload comprehensive test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-suite }}
          path: test-results/${{ matrix.test-suite }}
          retention-days: 30

  test-container-startup:
    name: Container Startup Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        container-type: [main-runner, chrome-runner]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Download built images
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.container-type == 'main-runner' && 'docker-image-primary' || 'docker-image-chrome' }}
          path: /tmp/

      - name: Load Docker images
        run: |
          # Load the built Docker images
          if [[ "${{ matrix.container-type }}" == "main-runner" ]]; then
            docker load < /tmp/github-runner-latest.tar
            echo "Loaded main runner image"
          else
            docker load < /tmp/github-runner-chrome-latest.tar
            echo "Loaded Chrome runner image"
          fi

          # Verify images are loaded
          docker images | grep github-runner

      - name: Set up container test environment
        run: |
          # Create test results directory
          mkdir -p test-results/container-startup/${{ matrix.container-type }}

          # Make test scripts executable
          chmod +x tests/integration/comprehensive-tests.sh

          # Create minimal test environment files
          mkdir -p config/test

          # Main runner test config
          cat > config/test/main-runner.env << 'EOF'
          GITHUB_TOKEN=test-token-not-real-for-testing
          GITHUB_REPOSITORY=test/repository
          RUNNER_NAME=test-main-runner-ci
          RUNNER_LABELS=test,ci,docker,self-hosted
          RUNNER_GROUP=test-group
          RUNNER_WORKDIR=/home/runner/_work
          EOF

          # Chrome runner test config
          cat > config/test/chrome-runner.env << 'EOF'
          GITHUB_TOKEN=test-token-not-real-for-testing
          GITHUB_REPOSITORY=test/repository
          RUNNER_NAME=test-chrome-runner-ci
          RUNNER_LABELS=chrome,ui-tests,selenium,playwright,cypress,headless
          RUNNER_GROUP=chrome-test-group
          DISPLAY=:99
          CHROME_FLAGS=--headless --no-sandbox --disable-dev-shm-usage --disable-gpu
          EOF

      - name: Test Main Runner Container Startup
        if: matrix.container-type == 'main-runner'
        run: |
          echo "🚀 Testing main GitHub runner container startup..."

          # Test container startup with docker-compose
          cd docker

          # Start the container with test configuration
          timeout 120 docker compose --env-file ../config/test/main-runner.env \
            -p ci-test-main up -d runner || {
              echo "❌ Failed to start main runner container"
              exit 1
            }

          # Get container ID
          CONTAINER_ID=$(docker compose -p ci-test-main ps -q runner)
          echo "Container ID: $CONTAINER_ID"

          # Wait for container to be ready
          echo "Waiting for container to be ready..."
          sleep 15

          # Check if container is running
          if ! docker ps --filter "id=$CONTAINER_ID" --filter "status=running" | grep -q "$CONTAINER_ID"; then
            echo "❌ Container not running"
            docker logs "$CONTAINER_ID" || true
            exit 1
          fi

          # Basic health checks
          echo "🔍 Performing health checks..."

          # Check basic command execution
          if ! docker exec "$CONTAINER_ID" whoami; then
            echo "❌ Basic command execution failed"
            exit 1
          fi

          # Check Docker-in-Docker
          if ! docker exec "$CONTAINER_ID" docker version; then
            echo "❌ Docker-in-Docker not working"
            exit 1
          fi

          # Check runner directory structure
          if ! docker exec "$CONTAINER_ID" test -d /home/runner; then
            echo "❌ Runner home directory not found"
            exit 1
          fi

          echo "✅ Main runner container startup test passed"

          # Cleanup
          docker compose -p ci-test-main down || true

      - name: Test Chrome Runner Container Startup
        if: matrix.container-type == 'chrome-runner'
        run: |
          echo "🚀 Testing Chrome GitHub runner container startup..."

          # Test container startup with docker-compose
          cd docker

          # Start the Chrome container with test configuration
          timeout 150 docker compose -f docker-compose.chrome.yml \
            --env-file ../config/test/chrome-runner.env \
            -p ci-test-chrome up -d chrome-runner || {
              echo "❌ Failed to start Chrome runner container"
              exit 1
            }

          # Get container ID
          CONTAINER_ID=$(docker compose -f docker-compose.chrome.yml -p ci-test-chrome ps -q chrome-runner)
          echo "Chrome Container ID: $CONTAINER_ID"

          # Wait for container to be ready (Chrome takes longer)
          echo "Waiting for Chrome container to be ready..."
          sleep 30

          # Check if container is running
          if ! docker ps --filter "id=$CONTAINER_ID" --filter "status=running" | grep -q "$CONTAINER_ID"; then
            echo "❌ Chrome container not running"
            docker logs "$CONTAINER_ID" || true
            exit 1
          fi

          # Chrome-specific health checks
          echo "🔍 Performing Chrome-specific health checks..."

          # Check Chrome installation
          if ! docker exec "$CONTAINER_ID" google-chrome --version; then
            echo "❌ Chrome not working"
            exit 1
          fi

          # Check ChromeDriver
          if ! docker exec "$CONTAINER_ID" chromedriver --version; then
            echo "❌ ChromeDriver not working"
            exit 1
          fi

          # Check Node.js (for frontend testing)
          if ! docker exec "$CONTAINER_ID" node --version; then
            echo "❌ Node.js not available"
            exit 1
          fi

          # Test headless Chrome functionality
          echo "Testing headless Chrome..."
          if docker exec "$CONTAINER_ID" timeout 30 google-chrome \
            --headless --no-sandbox --disable-dev-shm-usage \
            --virtual-time-budget=1000 --dump-dom about:blank > /tmp/chrome-test.html; then
            echo "✅ Chrome headless test passed"
          else
            echo "⚠️ Chrome headless test failed (may still work for CI)"
          fi

          echo "✅ Chrome runner container startup test passed"

          # Cleanup
          docker compose -f docker-compose.chrome.yml -p ci-test-chrome down || true

      - name: Verify Container Resource Usage
        run: |
          echo "📊 Checking container resource usage patterns..."

          # Check if containers have reasonable resource constraints
          cd docker

          if [[ "${{ matrix.container-type }}" == "main-runner" ]]; then
            COMPOSE_FILE="docker-compose.yml"
          else
            COMPOSE_FILE="docker-compose.chrome.yml"
          fi

          # Check for restart policies
          if ! grep -q "restart:" "$COMPOSE_FILE"; then
            echo "⚠️ No restart policy configured in $COMPOSE_FILE"
          else
            echo "✅ Restart policy configured"
          fi

          # Check for health checks
          if grep -q "healthcheck:" "$COMPOSE_FILE"; then
            echo "✅ Health check configured"
          else
            echo "💡 Consider adding health checks for production readiness"
          fi

          echo "Resource usage check completed"

      - name: Generate container startup report
        if: always()
        run: |
          # Create detailed startup test report
          REPORT_DIR="test-results/container-startup/${{ matrix.container-type }}"
          mkdir -p "$REPORT_DIR"

          echo "# Container Startup Test Report" > "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"
          echo "## Test Details" >> "$REPORT_DIR/startup-report.md"
          echo "- **Container Type**: ${{ matrix.container-type }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Test Date**: $(date -Iseconds)" >> "$REPORT_DIR/startup-report.md"
          echo "- **Workflow**: ${{ github.workflow }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Run ID**: ${{ github.run_id }}" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"

          # Add Docker info
          echo "## Docker Environment" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker version >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"

          # Add image info
          echo "## Image Information" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker images | grep github-runner >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"

      - name: Upload container startup test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: container-startup-results-${{ matrix.container-type }}
          path: test-results/container-startup/${{ matrix.container-type }}
          retention-days: 30

  security-container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Run Trivy vulnerability scanner on container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image-primary }}
          format: "sarif"
          output: "trivy-container-results.sarif"

      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-container-results.sarif"

  security-chrome-scan:
    name: Chrome Container Security Scan
    runs-on: ubuntu-latest
    needs: [build-chrome]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Run Trivy vulnerability scanner on Chrome container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-chrome.outputs.image-primary }}
          format: "sarif"
          output: "trivy-chrome-results.sarif"

      - name: Upload Chrome container scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-chrome-results.sarif"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs:
      [
        build,
        build-chrome,
        test-package-validation,
        test-comprehensive,
        test-container-startup,
        security-container-scan,
        security-chrome-scan,
      ]
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging-runners.example.com
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up staging environment
        run: |
          echo "Setting up staging deployment..."

          # Create staging directories
          mkdir -p staging-deploy

          # Copy deployment files
          cp -r docker/ staging-deploy/
          cp -r config/ staging-deploy/
          cp -r scripts/ staging-deploy/

      - name: Configure staging environment
        env:
          STAGING_GITHUB_TOKEN: ${{ secrets.STAGING_GITHUB_TOKEN }}
          STAGING_REPOSITORY: ${{ secrets.STAGING_REPOSITORY }}
        run: |
          cd staging-deploy

          # Update configuration for staging
          if [[ -f "config/runner.env" ]]; then
            sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=${{ secrets.STAGING_GITHUB_TOKEN }}/' config/runner.env
            sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=${{ secrets.STAGING_REPOSITORY }}/' config/runner.env
          fi

      - name: Deploy to staging
        run: |
          cd staging-deploy

          echo "Deploying to staging environment..."
          echo "Image: ${{ needs.build.outputs.image-tag }}"

          # In a real scenario, this would deploy to your staging infrastructure
          # For example: kubectl apply, docker stack deploy, etc.

          # Simulate deployment
          echo "Deployment completed successfully"

      - name: Run staging smoke tests
        run: |
          echo "Running smoke tests against staging..."

          # Add staging-specific health checks
          sleep 10

          # Simulate health check
          echo "Staging environment is healthy"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs:
      [
        build,
        build-chrome,
        test-package-validation,
        test-comprehensive,
        test-container-startup,
        security-container-scan,
        security-chrome-scan,
        deploy-staging,
      ]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')
    environment:
      name: production
      url: https://runners.example.com
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up production environment
        run: |
          echo "Setting up production deployment..."

          # Create production directories
          mkdir -p production-deploy

          # Copy deployment files
          cp -r docker/ production-deploy/
          cp -r config/ production-deploy/
          cp -r scripts/ production-deploy/

      - name: Configure production environment
        env:
          PROD_GITHUB_TOKEN: ${{ secrets.PROD_GITHUB_TOKEN }}
          PROD_REPOSITORY: ${{ secrets.PROD_REPOSITORY }}
        run: |
          cd production-deploy

          # Update configuration for production
          if [[ -f "config/runner.env" ]]; then
            sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=${{ secrets.PROD_GITHUB_TOKEN }}/' config/runner.env
            sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=${{ secrets.PROD_REPOSITORY }}/' config/runner.env
          fi

      - name: Deploy to production
        run: |
          cd production-deploy

          echo "Deploying to production environment..."
          echo "Image: ${{ needs.build.outputs.image-tag }}"

          # In a real scenario, this would deploy to your production infrastructure
          # For example: kubectl apply, docker stack deploy, etc.

          # Simulate deployment with blue/green strategy
          echo "Starting blue/green deployment..."
          echo "Production deployment completed successfully"

      - name: Run production health checks
        run: |
          echo "Running production health checks..."

          # Add production-specific health checks
          sleep 15

          # Simulate comprehensive health check
          echo "Production environment is healthy and ready"

      - name: Post-deployment monitoring setup
        run: |
          echo "Setting up post-deployment monitoring..."

          # In a real scenario, this would configure monitoring, alerts, etc.
          echo "Monitoring configured for production deployment"

  cleanup:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-production.result == 'failure')
    permissions:
      contents: read
      packages: write
    steps:
      - name: Clean up old container images
        run: |
          echo "Cleaning up old container images..."

          # In a real scenario, this would clean up old images from the registry
          # For example, keeping only the last 10 images
          echo "Cleanup completed"

      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."

          # Create deployment summary
          cat > deployment-report.md << 'EOF'
          # Deployment Report

          ## Summary
          - **Workflow Run ID**: ${{ github.run_id }}
          - **Commit SHA**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          - **Triggered by**: ${{ github.actor }}
          - **Timestamp**: $(date -u)

          ## Deployments
          - Production: ${{ needs.deploy-production.result }}

          ## Image Details
          - Registry: ${{ env.REGISTRY }}
          - Repository: ${{ env.IMAGE_NAME }}
          - Tags: Built and deployed successfully
          EOF

          cat deployment-report.md

      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: deployment-report.md
          retention-days: 90
