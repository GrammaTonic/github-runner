name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
    tags: ["v*.*.*"] # Tags trigger regardless of paths
  pull_request:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment for deployment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: "Skip testing steps"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Force rebuild Docker images (ignore cache)"
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

permissions:
  contents: read
  packages: write
  security-events: write
  pull-requests: write
  checks: write
  actions: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  lint-and-validate:
    name: Lint and Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate Docker files
        run: |
          # Check if Docker files exist
          find . -name "Dockerfile*" -type f | while read -r dockerfile; do
            echo "Validating $dockerfile"
            # Run hadolint but only fail on errors, not warnings
            if ! docker run --rm -i hadolint/hadolint hadolint --ignore DL3008 --ignore DL3015 --ignore DL3013 --ignore DL3016 --ignore DL3059 - < "$dockerfile"; then
              echo "Critical errors found in $dockerfile"
              exit 1
            fi
          done

      - name: Validate Docker Compose files
        run: |
          # Validate docker-compose.yml syntax
          if [[ -f "docker/docker-compose.yml" ]]; then
            docker compose -f docker/docker-compose.yml config --quiet
          fi

      - name: Validate shell scripts
        run: |
          # Install shellcheck
          sudo apt-get update && sudo apt-get install -y shellcheck

          # Check all shell scripts (fail on errors and warnings for better quality)
          find . -name "*.sh" -type f | while read -r script; do
            echo "Checking $script"
            shellcheck -S warning "$script" || exit 1
          done

      - name: Check environment file templates
        run: |
          # Validate environment file syntax (basic check)
          find config/ -name "*.env*" -type f 2>/dev/null | while read -r envfile; do
            echo "Validating $envfile"
            # Check for basic syntax issues in env files
            grep -v '^#' "$envfile" | grep -v '^$' | grep -qE '^[A-Za-z_][A-Za-z0-9_]*=' || {
              echo "Warning: $envfile may have invalid environment variable syntax"
            }
          done || true

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner on filesystem
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Check for secrets in repository
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.before }}
          head: HEAD
          extra_args: --debug --only-verified

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
      image-primary: ${{ steps.get-primary-tag.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix=sha-,enable={{is_default_branch}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          file: ./docker/Dockerfile
          push: true
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ inputs.force_rebuild || false }}

      - name: Get primary tag for security scan
        id: get-primary-tag
        if: success() && steps.build.conclusion == 'success'
        run: |
          # Extract the first tag from the multi-line tags output for security scanning
          TAGS="${{ steps.meta.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary tag for security scan: $PRIMARY_TAG"

      - name: Save Docker image as artifact
        if: success() && steps.build.conclusion == 'success'
        run: |
          # Save the primary image as tar for container startup tests
          PRIMARY_TAG="${{ steps.get-primary-tag.outputs.primary-tag }}"
          echo "Saving Docker image: $PRIMARY_TAG"
          docker save "$PRIMARY_TAG" -o github-runner-latest.tar
          ls -la github-runner-latest.tar

      - name: Upload Docker image artifact
        if: success() && steps.build.conclusion == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-primary
          path: github-runner-latest.tar
          retention-days: 1

  build-chrome:
    name: Build Chrome Runner Image
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build-chrome.outputs.digest }}
      image-tag: ${{ steps.meta-chrome.outputs.tags }}
      image-primary: ${{ steps.get-primary-tag-chrome.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Chrome runner metadata
        id: meta-chrome
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,suffix=-chrome
            type=ref,event=pr,suffix=-chrome
            type=ref,event=tag,suffix=-chrome
            type=semver,pattern={{version}}-chrome
            type=semver,pattern={{major}}.{{minor}}-chrome
            type=semver,pattern={{major}}-chrome
            type=sha,prefix=sha-,suffix=-chrome,enable={{is_default_branch}}
            type=raw,value=chrome-latest,enable={{is_default_branch}}

      - name: Build and push Chrome runner image
        id: build-chrome
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          file: ./docker/Dockerfile.chrome
          push: true
          load: true
          tags: ${{ steps.meta-chrome.outputs.tags }}
          labels: ${{ steps.meta-chrome.outputs.labels }}
          cache-from: type=gha,scope=chrome
          cache-to: type=gha,mode=max,scope=chrome
          no-cache: ${{ inputs.force_rebuild || false }}

      - name: Get primary Chrome tag for security scan
        id: get-primary-tag-chrome
        if: success() && steps.build-chrome.conclusion == 'success'
        run: |
          # Extract the first tag from the multi-line tags output for security scanning
          TAGS="${{ steps.meta-chrome.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary Chrome tag for security scan: $PRIMARY_TAG"

      - name: Save Chrome Docker image as artifact
        if: success() && steps.build-chrome.conclusion == 'success'
        run: |
          # Save the Chrome image as tar for container startup tests
          PRIMARY_TAG="${{ steps.get-primary-tag-chrome.outputs.primary-tag }}"
          echo "Saving Chrome Docker image: $PRIMARY_TAG"
          docker save "$PRIMARY_TAG" -o github-runner-chrome-latest.tar
          ls -la github-runner-chrome-latest.tar

      - name: Upload Chrome Docker image artifact
        if: success() && steps.build-chrome.conclusion == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-chrome
          path: github-runner-chrome-latest.tar
          retention-days: 1

  # Comprehensive Testing Suite
  test-package-validation:
    name: Package Validation Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Package Validation Tests
        run: |
          echo "üß™ Running comprehensive package validation tests..."

          # Make scripts executable
          chmod +x tests/docker/validate-packages.sh
          chmod +x tests/unit/package-validation.sh

          # Run package validation in dry-run mode first (syntax check)
          echo "Running package validation (dry-run)..."
          DRY_RUN=true tests/docker/validate-packages.sh

          # Run unit tests for package detection
          echo "Running unit tests for obsolete package detection..."
          tests/unit/package-validation.sh

      - name: Upload package validation results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: package-validation-results
          path: test-results/
          retention-days: 30

  test-comprehensive:
    name: Comprehensive Integration Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          [unit, integration, docker-validation, security, configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up test environment
        run: |
          # Install comprehensive test dependencies
          sudo apt-get update
          sudo apt-get install -y jq curl

          # Install hadolint for Docker linting (from GitHub releases)
          HADOLINT_VERSION="v2.12.0"
          wget -O /tmp/hadolint "https://github.com/hadolint/hadolint/releases/download/${HADOLINT_VERSION}/hadolint-Linux-x86_64"
          chmod +x /tmp/hadolint
          sudo mv /tmp/hadolint /usr/local/bin/hadolint

          # Verify hadolint installation
          hadolint --version || echo "Hadolint installation failed, will skip Docker linting"

          # Create test results directory
          mkdir -p test-results/${{ matrix.test-suite }}

          # Make all test scripts executable
          find tests/ -name "*.sh" -type f -exec chmod +x {} \;

      - name: Run Unit Tests
        if: matrix.test-suite == 'unit'
        run: |
          echo "üß™ Running unit tests..."

          # Run unit tests for package validation
          TEST_RESULTS_DIR="test-results/unit" tests/unit/package-validation.sh

      - name: Run Integration Tests
        if: matrix.test-suite == 'integration'
        run: |
          echo "üß™ Running integration tests..."

          # Create integration test results directory
          mkdir -p test-results/integration

          # Run focused integration tests for CI environment
          # Skip Docker builds and container tests (tested separately)

          integration_errors=0

          # Test 1: Dockerfile syntax validation
          echo "Validating Dockerfile syntax..."
          if command -v hadolint >/dev/null 2>&1; then
            for dockerfile in docker/Dockerfile*; do
              if [[ -f "$dockerfile" ]]; then
                if ! hadolint "$dockerfile" > "test-results/integration/hadolint-$(basename "$dockerfile").log" 2>&1; then
                  echo "‚ùå Hadolint failed for $dockerfile"
                  integration_errors=$((integration_errors + 1))
                fi
              fi
            done
          else
            echo "‚ÑπÔ∏è  Hadolint not available, skipping Docker linting"
          fi

          # Test 2: Docker Compose validation
          echo "Validating docker-compose files..."
          for compose_file in docker/docker-compose*.yml; do
            if [[ -f "$compose_file" ]]; then
              if ! docker-compose -f "$compose_file" config > "test-results/integration/compose-$(basename "$compose_file").log" 2>&1; then
                echo "‚ùå Docker Compose validation failed for $compose_file"
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done

          # Test 3: Configuration file validation
          echo "Validating configuration files..."
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              if [[ "$config_name" != "*.env" ]] && [[ "$config_name" == *.env* ]]; then
                echo "Checking $config_name format..."
                if ! grep -q "=" "$config_file"; then
                  echo "‚ùå Configuration file $config_name appears to be empty or invalid"
                  integration_errors=$((integration_errors + 1))
                fi
              fi
            fi
          done

          # Test 4: Script validation
          echo "Validating shell scripts..."
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              if ! bash -n "$script" > "test-results/integration/syntax-$script_name.log" 2>&1; then
                echo "‚ùå Syntax error in $script"
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done

          echo "Integration tests completed. Errors: $integration_errors"

          if [[ $integration_errors -gt 0 ]]; then
            echo "‚ùå Integration tests failed"
            exit 1
          else
            echo "‚úÖ Integration tests passed"
          fi

      - name: Run Docker Package Validation
        if: matrix.test-suite == 'docker-validation'
        run: |
          echo "üß™ Running Docker package validation..."

          # Create docker validation test results directory
          mkdir -p test-results/docker-validation

          # Run focused Docker package validation (without building)
          docker_errors=0

          # Test 1: Package duplication check
          echo "Checking for duplicate packages in Dockerfiles..."
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              
              # Extract package names from RUN commands that install packages
              packages=$(grep -E "RUN.*apt-get install|RUN.*apk add" "$dockerfile" | \
                sed -E 's/.*apt-get install[^a-zA-Z-]*//; s/.*apk add[^a-zA-Z-]*//; s/[\\&|;].*//; s/#.*//; s/\s+/ /g' | \
                tr ' ' '\n' | grep -E '^[a-zA-Z][a-zA-Z0-9.-]*$' | sort)
              
              # Check for duplicates
              duplicates=$(echo "$packages" | uniq -d)
              if [[ -n "$duplicates" ]]; then
                echo "‚ùå Duplicate packages found in $dockerfile_name:"
                echo "$duplicates"
                echo "$duplicates" > "test-results/docker-validation/duplicates-$dockerfile_name.log"
                docker_errors=$((docker_errors + 1))
              else
                echo "‚úÖ No duplicates in $dockerfile_name"
              fi
            fi
          done

          # Test 2: Obsolete package check
          echo "Checking for known obsolete packages..."
          obsolete_packages=("python2" "python2.7" "python-pip" "nodejs-legacy")
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              for pkg in "${obsolete_packages[@]}"; do
                if grep -q "$pkg" "$dockerfile"; then
                  echo "‚ùå Obsolete package '$pkg' found in $dockerfile_name"
                  echo "$pkg" >> "test-results/docker-validation/obsolete-$dockerfile_name.log"
                  docker_errors=$((docker_errors + 1))
                fi
              done
            fi
          done

          echo "Docker validation completed. Errors: $docker_errors"

          if [[ $docker_errors -gt 0 ]]; then
            echo "‚ùå Docker package validation failed"
            exit 1
          else
            echo "‚úÖ Docker package validation passed"
          fi

      - name: Run Security Tests
        if: matrix.test-suite == 'security'
        run: |
          echo "üß™ Running security validation tests..."

          # Create security test results directory
          mkdir -p test-results/security

          # Check for potential secrets
          echo "Checking for potential secrets..."
          secret_patterns=("password" "secret" "token" "key" "api_key" "auth")
          secrets_found=false

          for pattern in "${secret_patterns[@]}"; do
            if grep -r -i "$pattern" . \
                --exclude-dir=".git" \
                --exclude-dir="test-results" \
                --exclude-dir="logs" \
                --exclude="*.log" \
                --exclude="*.md" \
                | grep -v "# Example\|TODO\|FIXME\|template\|placeholder\|test.*$pattern" > "test-results/security/secrets-$pattern.log" 2>&1; then
              echo "‚ö†Ô∏è  Potential secrets pattern '$pattern' found"
              secrets_found=true
            fi
          done

          # Check Docker security practices
          echo "Checking Docker security practices..."
          security_issues=0

          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              
              # Check for running as root
              if ! grep -q "USER " "$dockerfile"; then
                echo "SECURITY: $dockerfile_name may run as root" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
              
              # Check for COPY . .
              if grep -q "COPY \. \." "$dockerfile"; then
                echo "SECURITY: $dockerfile_name uses 'COPY . .' - overly broad" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
            fi
          done

          echo "Security scan completed. Issues found: $security_issues"

      - name: Run Configuration Tests
        if: matrix.test-suite == 'configuration'
        run: |
          echo "üß™ Running configuration validation tests..."

          # Create configuration test results directory
          mkdir -p test-results/configuration

          config_errors=0

          # Test configuration files
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              
              echo "Validating $config_name..."
              
              # Syntax check
              if ! bash -n "$config_file" > "test-results/configuration/$config_name.log" 2>&1; then
                echo "‚ùå Syntax error in $config_name"
                config_errors=$((config_errors + 1))
              fi
              
              # Check for required variables
              required_vars=("GITHUB_TOKEN" "GITHUB_REPOSITORY")
              for var in "${required_vars[@]}"; do
                if ! grep -q "^$var\|^#.*$var" "$config_file"; then
                  echo "MISSING: $var not found in $config_name" >> "test-results/configuration/missing-vars.log"
                fi
              done
            fi
          done

          # Test scripts
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              
              # Syntax check
              if ! bash -n "$script" > "test-results/configuration/$script_name.log" 2>&1; then
                echo "‚ùå Syntax error in $script_name"
                config_errors=$((config_errors + 1))
              fi
            fi
          done

          echo "Configuration validation completed. Errors found: $config_errors"

          if [[ $config_errors -gt 0 ]]; then
            exit 1
          fi

      - name: Upload comprehensive test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-suite }}
          path: test-results/${{ matrix.test-suite }}
          retention-days: 30

  test-container-startup:
    name: Container Startup Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    if: ${{ !inputs.skip_tests || inputs.skip_tests == false }}
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        container-type: [main-runner, chrome-runner]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Download built images
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.container-type == 'main-runner' && 'docker-image-primary' || 'docker-image-chrome' }}
          path: /tmp/

      - name: Load Docker images
        run: |
          # Load the built Docker images and retag them for testing
          if [[ "${{ matrix.container-type }}" == "main-runner" ]]; then
            echo "Loading main runner image..."
            docker load < /tmp/github-runner-latest.tar
            
            # Get the loaded image tag and retag it for testing
            LOADED_TAG=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "ghcr.io.*github-runner" | grep -v "chrome" | head -1)
            echo "Loaded image tag: $LOADED_TAG"
            
            # Retag for easier testing
            docker tag "$LOADED_TAG" github-runner:latest
            echo "Retagged as github-runner:latest"
          else
            echo "Loading Chrome runner image..."
            docker load < /tmp/github-runner-chrome-latest.tar
            
            # Get the loaded Chrome image tag and retag it for testing
            LOADED_TAG=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "ghcr.io.*github-runner.*chrome" | head -1)
            echo "Loaded Chrome image tag: $LOADED_TAG"
            
            # Retag for easier testing
            docker tag "$LOADED_TAG" github-runner:chrome-latest
            echo "Retagged as github-runner:chrome-latest"
          fi

          # Verify images are loaded and tagged
          echo "Available Docker images:"
          docker images | grep github-runner

      - name: Set up container test environment
        run: |
          # Create test results directory
          mkdir -p test-results/container-startup/${{ matrix.container-type }}

          # Make test scripts executable
          chmod +x tests/integration/comprehensive-tests.sh

          # Create minimal test environment files
          mkdir -p config/test

          # Main runner test config
          cat > config/test/main-runner.env << 'EOF'
          GITHUB_TOKEN=test-token-not-real-for-testing
          GITHUB_REPOSITORY=test/repository
          RUNNER_NAME=test-main-runner-ci
          RUNNER_LABELS=test,ci,docker,self-hosted
          RUNNER_GROUP=test-group
          RUNNER_WORKDIR=/home/runner/_work
          EOF

          # Chrome runner test config
          cat > config/test/chrome-runner.env << 'EOF'
          GITHUB_TOKEN=test-token-not-real-for-testing
          GITHUB_REPOSITORY=test/repository
          RUNNER_NAME=test-chrome-runner-ci
          RUNNER_LABELS=chrome,ui-tests,selenium,playwright,cypress,headless
          RUNNER_GROUP=chrome-test-group
          DISPLAY=:99
          CHROME_FLAGS=--headless --no-sandbox --disable-dev-shm-usage --disable-gpu
          EOF

      - name: Test Main Runner Container Startup
        if: matrix.container-type == 'main-runner'
        run: |
          echo "üöÄ Testing main GitHub runner container startup..."

          # Test basic container startup without GitHub registration
          cd docker

          # Create a test script that bypasses GitHub registration for testing
          cat > test-entrypoint.sh << 'EOF'
          #!/bin/bash
          echo "=== Container Startup Test ==="
          echo "Testing basic container functionality..."

          # Basic system checks
          echo "‚úì Container started successfully"
          echo "‚úì Shell access working"
          echo "‚úì User context: $(whoami)"
          echo "‚úì Working directory: $(pwd)"
          echo "‚úì Available disk space:"
          df -h /
          echo "‚úì Memory info:"
          free -h
          echo "‚úì CPU info:"
          nproc

          # Test basic commands that runners need
          echo "‚úì Git available: $(git --version)"
          echo "‚úì Curl available: $(curl --version | head -1)"

          # Test Node.js if available
          if command -v node >/dev/null 2>&1; then
            echo "‚úì Node.js available: $(node --version)"
          fi

          # Test Python if available
          if command -v python3 >/dev/null 2>&1; then
            echo "‚úì Python available: $(python3 --version)"
          fi

          echo "=== Container startup test completed successfully ==="
          exit 0
          EOF

          chmod +x test-entrypoint.sh

          # Start container with test entrypoint
          CONTAINER_ID=$(docker run -d --name ci-test-main-runner \
            -v "$(pwd)/test-entrypoint.sh:/test-entrypoint.sh" \
            github-runner:latest /test-entrypoint.sh)

          echo "Container ID: $CONTAINER_ID"

          # Wait for container to complete
          echo "Waiting for container test to complete..."
          if ! timeout 60 docker wait "$CONTAINER_ID"; then
            echo "‚ùå Container test timed out"
            docker logs "$CONTAINER_ID" || true
            exit 1
          fi

          # Check exit code
          EXIT_CODE=$(docker inspect "$CONTAINER_ID" --format='{{.State.ExitCode}}')
          echo "Container exit code: $EXIT_CODE"

          # Show container logs
          echo "=== Container Logs ==="
          docker logs "$CONTAINER_ID"

          # Cleanup
          docker rm "$CONTAINER_ID" || true

          if [[ "$EXIT_CODE" -eq 0 ]]; then
            echo "‚úÖ Main runner container startup test passed"
          else
            echo "‚ùå Main runner container startup test failed"
            exit 1
          fi
          fi

          # Check Docker-in-Docker
          if ! docker exec "$CONTAINER_ID" docker version; then
            echo "‚ùå Docker-in-Docker not working"
            exit 1
          fi

          # Check runner directory structure
          if ! docker exec "$CONTAINER_ID" test -d /home/runner; then
            echo "‚ùå Runner home directory not found"
            exit 1
          fi

          echo "‚úÖ Main runner container startup test passed"

          # Cleanup
          docker compose -p ci-test-main down || true

      - name: Test Chrome Runner Container Startup
        if: matrix.container-type == 'chrome-runner'
        run: |
          echo "üöÄ Testing Chrome GitHub runner container startup..."

          # Test basic Chrome container startup without GitHub registration
          cd docker

          # Create a Chrome test script that bypasses GitHub registration
          cat > test-chrome-entrypoint.sh << 'EOF'
          #!/bin/bash
          echo "=== Chrome Container Startup Test ==="
          echo "Testing Chrome runner container functionality..."

          # Basic system checks
          echo "‚úì Chrome container started successfully"
          echo "‚úì Shell access working"
          echo "‚úì User context: $(whoami)"
          echo "‚úì Working directory: $(pwd)"

          # Test Chrome installation
          echo "Testing Chrome installation..."
          if command -v google-chrome >/dev/null 2>&1; then
            echo "‚úì Chrome available: $(google-chrome --version)"
          else
            echo "‚ùå Chrome not found"
            exit 1
          fi

          # Test ChromeDriver
          echo "Testing ChromeDriver..."
          if command -v chromedriver >/dev/null 2>&1; then
            echo "‚úì ChromeDriver available: $(chromedriver --version)"
          else
            echo "‚ùå ChromeDriver not found"
            exit 1
          fi

          # Test Node.js for frontend testing
          if command -v node >/dev/null 2>&1; then
            echo "‚úì Node.js available: $(node --version)"
          fi

          # Test npm for package management
          if command -v npm >/dev/null 2>&1; then
            echo "‚úì npm available: $(npm --version)"
          fi

          # Test Python for automation scripts
          if command -v python3 >/dev/null 2>&1; then
            echo "‚úì Python available: $(python3 --version)"
          fi

          # Test basic Chrome functionality (headless)
          echo "Testing Chrome headless functionality..."
          if timeout 30 google-chrome --headless --no-sandbox --disable-dev-shm-usage \
            --virtual-time-budget=1000 --dump-dom about:blank > /tmp/chrome-test.html 2>/dev/null; then
            echo "‚úì Chrome headless test passed"
          else
            echo "‚ö†Ô∏è Chrome headless test failed (may work in different environment)"
          fi

          echo "=== Chrome container startup test completed successfully ==="
          exit 0
          EOF

          chmod +x test-chrome-entrypoint.sh

          # Start container with test entrypoint
          CONTAINER_ID=$(docker run -d --name ci-test-chrome-runner \
            -v "$(pwd)/test-chrome-entrypoint.sh:/test-chrome-entrypoint.sh" \
            github-runner:chrome-latest /test-chrome-entrypoint.sh)

          echo "Chrome Container ID: $CONTAINER_ID"

          # Wait for container to complete (Chrome may take longer)
          echo "Waiting for Chrome container test to complete..."
          if ! timeout 120 docker wait "$CONTAINER_ID"; then
            echo "‚ùå Chrome container test timed out"
            docker logs "$CONTAINER_ID" || true
            exit 1
          fi

          # Check exit code
          EXIT_CODE=$(docker inspect "$CONTAINER_ID" --format='{{.State.ExitCode}}')
          echo "Chrome container exit code: $EXIT_CODE"

          # Show container logs
          echo "=== Chrome Container Logs ==="
          docker logs "$CONTAINER_ID"

          # Cleanup
          docker rm "$CONTAINER_ID" || true

          if [[ "$EXIT_CODE" -eq 0 ]]; then
            echo "‚úÖ Chrome runner container startup test passed"
          else
            echo "‚ùå Chrome runner container startup test failed"
            exit 1
          fi

      - name: Verify Container Resource Usage
        run: |
          echo "üìä Checking container resource usage patterns..."

          # Check if containers have reasonable resource constraints
          cd docker

          if [[ "${{ matrix.container-type }}" == "main-runner" ]]; then
            COMPOSE_FILE="docker-compose.yml"
          else
            COMPOSE_FILE="docker-compose.chrome.yml"
          fi

          # Check for restart policies
          if ! grep -q "restart:" "$COMPOSE_FILE"; then
            echo "‚ö†Ô∏è No restart policy configured in $COMPOSE_FILE"
          else
            echo "‚úÖ Restart policy configured"
          fi

          # Check for health checks
          if grep -q "healthcheck:" "$COMPOSE_FILE"; then
            echo "‚úÖ Health check configured"
          else
            echo "üí° Consider adding health checks for production readiness"
          fi

          echo "Resource usage check completed"

      - name: Generate container startup report
        if: always()
        run: |
          # Create detailed startup test report
          REPORT_DIR="test-results/container-startup/${{ matrix.container-type }}"
          mkdir -p "$REPORT_DIR"

          echo "# Container Startup Test Report" > "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"
          echo "## Test Details" >> "$REPORT_DIR/startup-report.md"
          echo "- **Container Type**: ${{ matrix.container-type }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Test Date**: $(date -Iseconds)" >> "$REPORT_DIR/startup-report.md"
          echo "- **Workflow**: ${{ github.workflow }}" >> "$REPORT_DIR/startup-report.md"
          echo "- **Run ID**: ${{ github.run_id }}" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"

          # Add Docker info
          echo "## Docker Environment" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker version >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          echo "" >> "$REPORT_DIR/startup-report.md"

          # Add image info
          echo "## Image Information" >> "$REPORT_DIR/startup-report.md"
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"
          docker images | grep github-runner >> "$REPORT_DIR/startup-report.md" 2>&1 || true
          echo "\`\`\`" >> "$REPORT_DIR/startup-report.md"

      - name: Upload container startup test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: container-startup-results-${{ matrix.container-type }}
          path: test-results/container-startup/${{ matrix.container-type }}
          retention-days: 30

  security-container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Trivy vulnerability scanner on container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image-primary }}
          format: "sarif"
          output: "trivy-container-results.sarif"

      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-container-results.sarif"

  security-chrome-scan:
    name: Chrome Container Security Scan
    runs-on: ubuntu-latest
    needs: [build-chrome]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Trivy vulnerability scanner on Chrome container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-chrome.outputs.image-primary }}
          format: "sarif"
          output: "trivy-chrome-results.sarif"

      - name: Upload Chrome container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-chrome-results.sarif"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs:
      [
        build,
        build-chrome,
        test-package-validation,
        test-comprehensive,
        test-container-startup,
        security-container-scan,
        security-chrome-scan,
      ]
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging-runners.example.com
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up staging environment
        run: |
          echo "Setting up staging deployment..."

          # Create staging directories
          mkdir -p staging-deploy

          # Copy deployment files
          cp -r docker/ staging-deploy/
          cp -r config/ staging-deploy/
          cp -r scripts/ staging-deploy/

      - name: Configure staging environment
        env:
          STAGING_GITHUB_TOKEN: ${{ secrets.STAGING_GITHUB_TOKEN }}
          STAGING_REPOSITORY: ${{ secrets.STAGING_REPOSITORY }}
        run: |
          cd staging-deploy

          # Update configuration for staging
          if [[ -f "config/runner.env" ]]; then
            sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=${{ secrets.STAGING_GITHUB_TOKEN }}/' config/runner.env
            sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=${{ secrets.STAGING_REPOSITORY }}/' config/runner.env
          fi

      - name: Deploy to staging
        run: |
          cd staging-deploy

          echo "Deploying to staging environment..."
          echo "Image: ${{ needs.build.outputs.image-tag }}"

          # In a real scenario, this would deploy to your staging infrastructure
          # For example: kubectl apply, docker stack deploy, etc.

          # Simulate deployment
          echo "Deployment completed successfully"

      - name: Run staging smoke tests
        run: |
          echo "Running smoke tests against staging..."

          # Add staging-specific health checks
          sleep 10

          # Simulate health check
          echo "Staging environment is healthy"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs:
      [
        build,
        build-chrome,
        test-package-validation,
        test-comprehensive,
        test-container-startup,
        security-container-scan,
        security-chrome-scan,
        deploy-staging,
      ]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')
    environment:
      name: production
      url: https://runners.example.com
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up production environment
        run: |
          echo "Setting up production deployment..."

          # Create production directories
          mkdir -p production-deploy

          # Copy deployment files
          cp -r docker/ production-deploy/
          cp -r config/ production-deploy/
          cp -r scripts/ production-deploy/

      - name: Configure production environment
        env:
          PROD_GITHUB_TOKEN: ${{ secrets.PROD_GITHUB_TOKEN }}
          PROD_REPOSITORY: ${{ secrets.PROD_REPOSITORY }}
        run: |
          cd production-deploy

          # Update configuration for production
          if [[ -f "config/runner.env" ]]; then
            sed -i 's/GITHUB_TOKEN=.*/GITHUB_TOKEN=${{ secrets.PROD_GITHUB_TOKEN }}/' config/runner.env
            sed -i 's/GITHUB_REPOSITORY=.*/GITHUB_REPOSITORY=${{ secrets.PROD_REPOSITORY }}/' config/runner.env
          fi

      - name: Deploy to production
        run: |
          cd production-deploy

          echo "Deploying to production environment..."
          echo "Image: ${{ needs.build.outputs.image-tag }}"

          # In a real scenario, this would deploy to your production infrastructure
          # For example: kubectl apply, docker stack deploy, etc.

          # Simulate deployment with blue/green strategy
          echo "Starting blue/green deployment..."
          echo "Production deployment completed successfully"

      - name: Run production health checks
        run: |
          echo "Running production health checks..."

          # Add production-specific health checks
          sleep 15

          # Simulate comprehensive health check
          echo "Production environment is healthy and ready"

      - name: Post-deployment monitoring setup
        run: |
          echo "Setting up post-deployment monitoring..."

          # In a real scenario, this would configure monitoring, alerts, etc.
          echo "Monitoring configured for production deployment"

  cleanup:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-production.result == 'failure')
    permissions:
      contents: read
      packages: write
    steps:
      - name: Clean up old container images
        run: |
          echo "Cleaning up old container images..."

          # In a real scenario, this would clean up old images from the registry
          # For example, keeping only the last 10 images
          echo "Cleanup completed"

      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."

          # Create deployment summary
          cat > deployment-report.md << 'EOF'
          # Deployment Report

          ## Summary
          - **Workflow Run ID**: ${{ github.run_id }}
          - **Commit SHA**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          - **Triggered by**: ${{ github.actor }}
          - **Timestamp**: $(date -u)

          ## Deployments
          - Production: ${{ needs.deploy-production.result }}

          ## Image Details
          - Registry: ${{ env.REGISTRY }}
          - Repository: ${{ env.IMAGE_NAME }}
          - Tags: Built and deployed successfully
          EOF

          cat deployment-report.md

      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: deployment-report.md
          retention-days: 90
