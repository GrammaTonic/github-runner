name: CI/CD Pipeline
# Canonical branch flow for this repository:
# - Feature work: create feature branches from `develop` and open PRs targeting `develop` (feature -> develop).
# - Integration: merge feature PRs into `develop` and run integration/user-experience checks on those PRs.
# - Promotion: create a PR from `develop` -> `main` to promote integrated changes to production; CI also validates promotions.
#
# Jobs in this workflow are intentionally conservative:
# - Many jobs run on both `develop` and `main` pushes to keep staging and deployment paths intact.
# - Job-level `if:` guards that check `github.event.pull_request.base.ref` are updated to account for feature PRs targeting `develop` as well as promotion PRs from `develop`->`main`.
# Edit with care: updating triggers or branch checks may affect deployment or baseline seeding behavior.
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
    paths:
      - "docker/**"
      - "scripts/**"
      - "config/**"
      - "monitoring/**"
      - ".github/workflows/**"
      - "tests/**"
      - "docs/**"
  workflow_dispatch:
    inputs:
      skip_tests:
        description: "Skip testing steps"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Force rebuild Docker images (ignore cache)"
        required: false
        default: false
        type: boolean
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}
permissions:
  contents: read
  packages: write
  security-events: write
  pull-requests: write
  checks: write
  actions: read
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  IMAGE_CHROME_NAME: ${{ github.repository }}-chrome
  IMAGE_CHROME_GO_NAME: ${{ github.repository }}-chrome-go
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
jobs:
  provision-normal-runner:
    name: Provision Normal Runner
    runs-on: ubuntu-latest
    needs: [build]
    # Skip provisioning for Dependabot PRs as secrets.REG_TOKEN is not available
    if: github.actor != 'dependabot[bot]'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Inject built normal runner image tag into docker-compose.production.yml
        env:
          NORMAL_IMAGE_TAG: ${{ needs.build.outputs.normal-image-primary }}
        run: |
          echo "Injecting built normal runner image tag into docker-compose.production.yml..."
          sed -i.bak "s|image: ghcr.io/grammatonic/github-runner:latest|image: $NORMAL_IMAGE_TAG|" docker/docker-compose.production.yml
          echo "Updated image line in docker-compose.production.yml to: $NORMAL_IMAGE_TAG"
      - name: Pull and verify built normal runner image
        env:
          NORMAL_IMAGE_TAG: ${{ needs.build.outputs.normal-image-primary }}
        run: |
          docker pull "$NORMAL_IMAGE_TAG"
          echo "Pulled normal runner image: $NORMAL_IMAGE_TAG"
      - name: Provision normal runner container in staging
        env:
          RUNNER_LABELS: staging,ci,self-hosted
          GITHUB_TOKEN: ${{ secrets.REG_TOKEN }}
        run: |
          echo "Provisioning normal runner container in staging..."
          echo "Using labels: $RUNNER_LABELS"
          echo "Injecting GITHUB_TOKEN from secrets.REG_TOKEN"
          docker compose -f docker/docker-compose.production.yml up -d
          echo "Checking if normal runner container is running..."
          if [ "$(docker ps -q -f name=github-runner-main)" ]; then
            echo "Normal runner container is running."
            else
            echo "Normal runner container is not running! Printing status and logs for diagnostics:"
            docker ps -a
            docker logs github-runner-main || echo "No logs available."
            exit 1
            fi
      - name: Health check normal runner container
        run: |
          echo "Checking health of normal runner container..."
          if ! docker ps -a --format '{{.Names}}' | grep -q '^github-runner-main$'; then
            echo "ERROR: github-runner-main container does not exist. Skipping health check."
            exit 1
          fi
          MAX_RETRIES=12
          RETRY_INTERVAL=5
          for i in $(seq 1 $MAX_RETRIES); do
            HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' github-runner-main)
            echo "Full health JSON: $HEALTH_JSON"
            STATUS=$(echo "$HEALTH_JSON" | jq -r '.Status')
            FAILING_STREAK=$(echo "$HEALTH_JSON" | jq -r '.FailingStreak')
            LOG_LENGTH=$(echo "$HEALTH_JSON" | jq -r '.Log | length')
            echo "Health status: $STATUS"
            echo "Failing streak: $FAILING_STREAK"
            echo "Health log entries: $LOG_LENGTH"
            if [ "$STATUS" = "healthy" ]; then
            echo "Normal runner container health is healthy."
            break
            elif [ "$STATUS" = "unhealthy" ] && [ "$LOG_LENGTH" = "0" ]; then
            # Container just started, Docker hasn't run healthcheck yet
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Health status is 'unhealthy' but no healthchecks have run yet. Waiting $RETRY_INTERVAL seconds before retry ($i/$MAX_RETRIES)..."
              sleep $RETRY_INTERVAL
            else
              echo "WARNING: Normal runner container never became healthy after $MAX_RETRIES retries."
              docker logs github-runner-main || echo "No logs available."
              exit 1
            fi
            elif [ "$STATUS" = "unhealthy" ]; then
            echo "ERROR: Normal runner container is unhealthy!"
            echo "Health logs:"
            echo "$HEALTH_JSON" | jq -r '.Log'
            docker logs github-runner-main || echo "No container logs available."
            exit 1
            elif [ "$STATUS" = "starting" ]; then
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Health status is 'starting', waiting $RETRY_INTERVAL seconds before retry ($i/$MAX_RETRIES)..."
              sleep $RETRY_INTERVAL
            else
              echo "WARNING: Normal runner container health is still 'starting' after $MAX_RETRIES retries."
              exit 1
            fi
            else
            echo "Unknown health status: $STATUS"
            exit 1
            fi
          done
      - name: Check normal runner container for GitHub connection
        run: |
          echo "Checking normal runner container logs for GitHub connection..."
          if docker logs github-runner-main | grep -q "Connected to GitHub"; then
          echo "âœ… Normal runner successfully connected to GitHub."
          else
          echo "âŒ Normal runner did NOT connect to GitHub. Printing logs for diagnostics:"
          docker logs github-runner-main
          exit 1
          fi
  provision-chrome-runner:
    name: Provision Chrome Runner For testing
    runs-on: ubuntu-latest
    needs: [build-chrome]
    # Skip provisioning for Dependabot PRs as secrets.REG_TOKEN is not available
    if: github.actor != 'dependabot[bot]'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Inject built Chrome runner image tag into docker-compose.chrome.yml
        env:
          CHROME_IMAGE_TAG: ${{ needs.build-chrome.outputs.chrome-image-primary }}
        run: |
          echo "Injecting built Chrome runner image tag into docker-compose.chrome.yml..."
          sed -i.bak "s|image: ghcr.io/grammatonic/github-runner:chrome-latest|image: $CHROME_IMAGE_TAG|" docker/docker-compose.chrome.yml
          echo "Updated image line in docker-compose.chrome.yml to: $CHROME_IMAGE_TAG"
      - name: Pull and verify built Chrome runner image
        env:
          CHROME_IMAGE_TAG: ${{ needs.build-chrome.outputs.chrome-image-primary }}
        run: |
          docker pull "$CHROME_IMAGE_TAG"
          echo "Pulled Chrome runner image: $CHROME_IMAGE_TAG"
      - name: Provision Chrome runner container in staging
        env:
          RUNNER_LABELS: chrome,ui-tests,extra-label
          GITHUB_TOKEN: ${{ secrets.REG_TOKEN }}
        run: |
          echo "Provisioning Chrome runner container in staging..."
          echo "Using labels: $RUNNER_LABELS"
          echo "Injecting GITHUB_TOKEN from secrets.REG_TOKEN"
          docker compose -f docker/docker-compose.chrome.yml up -d
          echo "Checking if Chrome runner container is running..."
          RUNNING=$(docker ps --filter "name=github-runner-chrome" --filter "status=running" -q)
          if [ -z "$RUNNING" ]; then
            echo "ERROR: Chrome runner container is not running! Printing status and logs:"
            docker ps -a
            docker logs github-runner-chrome || echo "No logs available."
            exit 1
          else
            echo "Chrome runner container is running."
              echo "--- Chrome runner container logs (post-startup) ---"
              docker logs github-runner-chrome || echo "No logs available."
              echo "--- End of Chrome runner container logs ---"
          fi
      - name: Health check Chrome runner container
        run: |
            echo "Checking health of Chrome runner container..."
            MAX_RETRIES=6
            RETRY_INTERVAL=5
            for i in $(seq 1 $MAX_RETRIES); do
              HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' github-runner-chrome)
              echo "Full health JSON: $HEALTH_JSON"
              STATUS=$(echo "$HEALTH_JSON" | jq -r '.Status')
              FAILING_STREAK=$(echo "$HEALTH_JSON" | jq -r '.FailingStreak')
              LOGS=$(echo "$HEALTH_JSON" | jq -r '.Log | @json')
              echo "Health status: $STATUS"
              echo "Failing streak: $FAILING_STREAK"
              echo "Health logs: $LOGS"
              if [ "$STATUS" = "healthy" ]; then
                echo "Chrome runner container health is healthy."
                break
              elif [ "$STATUS" = "unhealthy" ]; then
                echo "ERROR: Chrome runner container is unhealthy!"
                exit 1
              elif [ "$STATUS" = "starting" ]; then
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "Health status is 'starting', waiting $RETRY_INTERVAL seconds before retry ($i/$MAX_RETRIES)..."
                  sleep $RETRY_INTERVAL
                else
                  echo "WARNING: Chrome runner container health is still 'starting' after $MAX_RETRIES retries."
                  exit 1
                fi
              else
                echo "Unknown health status: $STATUS"
                exit 1
              fi
            done
      - name: Check Chrome runner container for GitHub connection
        run: |
          echo "Checking Chrome runner container logs for GitHub connection..."
          if docker logs github-runner-chrome | grep -q "Connected to GitHub"; then
            echo "âœ… Chrome runner successfully connected to GitHub."
          else
            echo "âŒ Chrome runner did NOT connect to GitHub. Printing logs for diagnostics:"
            docker logs github-runner-chrome
            exit 1
          fi
      - name: Run playwright screenshot test on Chrome runner
        run: |
          echo "Running Playwright screenshot integration script..."
          chmod +x tests/integration/playwright_screenshot_integration.sh
          CONTAINER_NAME=github-runner-chrome tests/integration/playwright_screenshot_integration.sh
      - name: Upload Playwright screenshot artifact
        uses: actions/upload-artifact@v5
        with:
          name: playwright-google-screenshot
          path: test-results/playwright/google_screenshot_*.png
          retention-days: 30
  provision-chrome-go-runner:
    name: Provision Chrome-Go Runner
    runs-on: ubuntu-latest
    needs: [build-chrome-go]
    # Skip provisioning for Dependabot PRs as secrets.REG_TOKEN is not available
    if: github.actor != 'dependabot[bot]'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Inject built Chrome-Go runner image tag into docker-compose.chrome-go.yml
        env:
          CHROME_GO_IMAGE_TAG: ${{ needs.build-chrome-go.outputs.chrome-go-image-primary }}
        run: |
          echo "Injecting built Chrome-Go runner image tag into docker-compose.chrome-go.yml..."
          sed -i.bak "s|image: ghcr.io/grammatonic/github-runner:chrome-go-latest|image: $CHROME_GO_IMAGE_TAG|" docker/docker-compose.chrome-go.yml
          echo "Updated image line in docker-compose.chrome-go.yml to: $CHROME_GO_IMAGE_TAG"
      - name: Pull and verify built Chrome-Go runner image
        env:
          CHROME_GO_IMAGE_TAG: ${{ needs.build-chrome-go.outputs.chrome-go-image-primary }}
        run: |
          docker pull "$CHROME_GO_IMAGE_TAG"
          echo "Pulled Chrome-Go runner image: $CHROME_GO_IMAGE_TAG"
      - name: Provision Chrome-Go runner container in staging
        env:
          GITHUB_TOKEN: ${{ secrets.REG_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "Setting up Chrome-Go runner configuration..."
          # Copy the example config file
          cp config/chrome-go-runner.env.example config/chrome-go-runner.env
          
          # Update the config file with actual values
          sed -i.bak "s|GITHUB_TOKEN=ghp_your_personal_access_token_here|GITHUB_TOKEN=$GITHUB_TOKEN|" config/chrome-go-runner.env
          sed -i.bak "s|GITHUB_REPOSITORY=your-username/your-repo-name|GITHUB_REPOSITORY=$GITHUB_REPOSITORY|" config/chrome-go-runner.env
          
          echo "Provisioning Chrome-Go runner container in staging..."
          echo "Using configuration from config/chrome-go-runner.env"
          echo "Injecting GITHUB_TOKEN from secrets.REG_TOKEN"
          
          # Use --env-file to load configuration
          docker compose --env-file config/chrome-go-runner.env -f docker/docker-compose.chrome-go.yml up -d
          
          echo "Checking if Chrome-Go runner container is running..."
          RUNNING=$(docker ps --filter "name=github-runner-chrome-go" --filter "status=running" -q)
          if [ -z "$RUNNING" ]; then
            echo "ERROR: Chrome-Go runner container is not running! Printing status and logs:"
            docker ps -a
            docker logs github-runner-chrome-go || echo "No logs available."
            exit 1
          else
            echo "Chrome-Go runner container is running."
              echo "--- Chrome-Go runner container logs (post-startup) ---"
              docker logs github-runner-chrome-go || echo "No logs available."
              echo "--- End of Chrome-Go runner container logs ---"
          fi
      - name: Health check Chrome-Go runner container
        run: |
            echo "Checking health of Chrome-Go runner container..."
            MAX_RETRIES=6
            RETRY_INTERVAL=5
            for i in $(seq 1 $MAX_RETRIES); do
              HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' github-runner-chrome-go)
              echo "Full health JSON: $HEALTH_JSON"
              STATUS=$(echo "$HEALTH_JSON" | jq -r '.Status')
              FAILING_STREAK=$(echo "$HEALTH_JSON" | jq -r '.FailingStreak')
              LOGS=$(echo "$HEALTH_JSON" | jq -r '.Log | @json')
              echo "Health status: $STATUS"
              echo "Failing streak: $FAILING_STREAK"
              echo "Health logs: $LOGS"
              if [ "$STATUS" = "healthy" ]; then
                echo "Chrome-Go runner container health is healthy."
                break
              elif [ "$STATUS" = "unhealthy" ]; then
                echo "ERROR: Chrome-Go runner container is unhealthy!"
                exit 1
              elif [ "$STATUS" = "starting" ]; then
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "Health status is 'starting', waiting $RETRY_INTERVAL seconds before retry ($i/$MAX_RETRIES)..."
                  sleep $RETRY_INTERVAL
                else
                  echo "WARNING: Chrome-Go runner container health is still 'starting' after $MAX_RETRIES retries."
                  exit 1
                fi
              else
                echo "Unknown health status: $STATUS"
                exit 1
              fi
            done
      - name: Check Chrome-Go runner container for GitHub connection
        run: |
          echo "Checking Chrome-Go runner container logs for GitHub connection..."
          if docker logs github-runner-chrome-go | grep -q "Connected to GitHub"; then
            echo "âœ… Chrome-Go runner successfully connected to GitHub."
          else
            echo "âŒ Chrome-Go runner did NOT connect to GitHub. Printing logs for diagnostics:"
            docker logs github-runner-chrome-go
            exit 1
          fi
      - name: Verify Go installation in Chrome-Go runner
        run: |
          echo "Verifying Go installation in Chrome-Go runner..."
          if docker exec github-runner-chrome-go go version; then
            echo "âœ… Go is installed and working in Chrome-Go runner."
          else
            echo "âŒ Go is not properly installed in Chrome-Go runner."
            exit 1
          fi
      - name: Run playwright screenshot test on Chrome-Go runner
        run: |
          echo "Running Playwright screenshot integration script..."
          chmod +x tests/integration/playwright_screenshot_integration.sh
          CONTAINER_NAME=github-runner-chrome-go tests/integration/playwright_screenshot_integration.sh
      - name: Upload Playwright screenshot artifact
        uses: actions/upload-artifact@v5
        with:
          name: playwright-chrome-go-google-screenshot
          path: test-results/playwright/google_screenshot_*.png
          retention-days: 30
  lint-and-validate:
    name: Lint and Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      statuses: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false
      - name: Run GitHub Super Linter 
        id: lint
        uses: super-linter/super-linter/slim@v8.2.1
        env:
          DEFAULT_BRANCH: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref || github.ref_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: true
          VALIDATE_DOCKERFILE: true
          VALIDATE_DOCKERFILE_HADOLINT: true
          FILTER_REGEX_EXCLUDE: docs/archive/.*
          VALIDATE_BASH: true
          VALIDATE_SHELL_SHFMT: true
          VALIDATE_YAML: true
          VALIDATE_JSON: true
          VALIDATE_MD: true
          # report in SARIF format for GitHub code scanning dont fail this step on lint errors
          FAIL_ON_ERROR: false
          SAVE_SUPER_LINTER_OUTPUT: true
      - name: Validate Docker Compose files
        run: |
          # Validate separate compose files syntax
          if [[ -f "docker/docker-compose.production.yml" ]]; then
            docker compose -f docker/docker-compose.production.yml config --quiet
          fi
          if [[ -f "docker/docker-compose.chrome.yml" ]]; then
            docker compose -f docker/docker-compose.chrome.yml config --quiet
          fi
      - name: Check environment file templates
        run: |
          # Validate environment file syntax (basic check)
          find config/ -name "*.env*" -type f 2>/dev/null | while read -r envfile; do
            echo "Validating $envfile"
            # Check for basic syntax issues in env files
            grep -v '^#' "$envfile" | grep -v '^$' | grep -qE '^[A-Za-z_][A-Za-z0-9_]*=' || {
              echo "Warning: $envfile may have invalid environment variable syntax"
            }
          done || true
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Run Trivy vulnerability scanner on filesystem
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"
      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: "trivy-results.sarif"
          category: "security-scan"
      - name: Check for secrets in repository
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.before }}
          head: HEAD
          extra_args: --debug --only-verified
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      normal-image-digest: ${{ steps.build.outputs.digest }}
      normal-image-tag: ${{ steps.meta.outputs.tags }}
      normal-image-primary: ${{ steps.get-primary-tag.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Extract normal runner metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
      - name: Determine normal build no-cache
        id: force-rebuild-normal
        run: |
          # Determine whether to force rebuild for the normal build
          INPUT_VAL="${{ github.event.inputs.force_rebuild || '' }}"
          HEAD_MSG="${{ github.event.head_commit.message || '' }}"
          echo "event_input=$INPUT_VAL"
          echo "head_commit_message=$HEAD_MSG"
          if [ "$INPUT_VAL" = "true" ] || echo "$HEAD_MSG" | grep -q '\[force rebuild\]'; then
            echo "force_rebuild=true" >> $GITHUB_OUTPUT
            # Clear cache settings so build-push-action won't attempt to import caches
            printf "CACHE_FROM=\nCACHE_TO=\n" >> $GITHUB_ENV
            echo "cache_from=" >> $GITHUB_OUTPUT
            echo "cache_to=" >> $GITHUB_OUTPUT
          else
            echo "force_rebuild=false" >> $GITHUB_OUTPUT
            # Provide the default cache sources (multi-line) via GITHUB_ENV
            # Use cross-branch cache to leverage builds from feature branches and other branches
            printf "CACHE_FROM=type=gha\ntype=gha,scope=normal-runner\ntype=gha,scope=buildcache\n" >> $GITHUB_ENV
            printf "CACHE_TO=type=gha,mode=max,scope=normal-runner\ntype=gha,mode=max,scope=buildcache\n" >> $GITHUB_ENV
            # Also emit as step outputs so other action inputs can reference them (multi-line)
            echo "cache_from<<EOF" >> $GITHUB_OUTPUT
            echo "type=gha" >> $GITHUB_OUTPUT
            echo "type=gha,scope=normal-runner" >> $GITHUB_OUTPUT
            echo "type=gha,scope=buildcache" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cache_to<<EOF" >> $GITHUB_OUTPUT
            echo "type=gha,mode=max,scope=normal-runner" >> $GITHUB_OUTPUT
            echo "type=gha,mode=max,scope=buildcache" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
      - name: Build and push normal runner Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./docker
          platforms: linux/amd64
          file: ./docker/Dockerfile
          push: true
          load: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: ${{ steps.force-rebuild-normal.outputs.cache_from }}
          cache-to: ${{ steps.force-rebuild-normal.outputs.cache_to }}
          no-cache: ${{ steps.force-rebuild-normal.outputs.force_rebuild == 'true' }}
      - name: Get primary normal runner tag for security scan
        id: get-primary-tag
        if: success() && steps.build.conclusion == 'success'
        run: |
          TAGS="${{ steps.meta.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary normal runner tag for security scan: $PRIMARY_TAG"
          echo "Normal runner image pushed to registry: $PRIMARY_TAG"
          echo "$PRIMARY_TAG" > build-normal-image-tag.txt
          echo "${{ steps.build.outputs.digest }}" > build-normal-image-digest.txt
      - name: Upload normal runner build image tag as artifact
        uses: actions/upload-artifact@v5
        with:
          name: build-normal-image-tag
          path: build-normal-image-tag.txt
          retention-days: 30
      - name: Upload normal runner build image digest as artifact
        uses: actions/upload-artifact@v5
        with:
          name: build-normal-image-digest
          path: build-normal-image-digest.txt
          retention-days: 30
  build-chrome:
    name: Build Chrome Runner Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      chrome-image-digest: ${{ steps.build-chrome.outputs.digest }}
      chrome-image-tag: ${{ steps.meta-chrome.outputs.tags }}
      chrome-image-primary: ${{ steps.get-primary-tag-chrome.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Extract Chrome runner metadata
        id: meta-chrome
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_CHROME_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
          labels: |
            org.opencontainers.image.name=github-runner-chrome
      - name: Determine Chrome build no-cache
        id: force-rebuild-chrome
        run: |
          # Determine whether to force rebuild for the Chrome build
          INPUT_VAL="${{ github.event.inputs.force_rebuild || '' }}"
          HEAD_MSG="${{ github.event.head_commit.message || '' }}"
          echo "event_input=$INPUT_VAL"
          echo "head_commit_message=$HEAD_MSG"
          if [ "$INPUT_VAL" = "true" ] || echo "$HEAD_MSG" | grep -q '\[force rebuild\]'; then
            echo "force_rebuild=true" >> $GITHUB_OUTPUT
            # Clear cache settings so build-push-action won't attempt to import caches
            printf "CACHE_FROM=\nCACHE_TO=\n" >> $GITHUB_ENV
          else
            echo "force_rebuild=false" >> $GITHUB_OUTPUT
            # Provide the default cache sources (multi-line) via GITHUB_ENV
            # Use cross-branch cache to leverage builds from feature branches and other branches
            printf "CACHE_FROM=type=gha\ntype=gha,scope=chrome-runner\ntype=gha,scope=buildcache\n" >> $GITHUB_ENV
            printf "CACHE_TO=type=gha,mode=max,scope=chrome-runner\ntype=gha,mode=max,scope=buildcache\n" >> $GITHUB_ENV
            # Also emit as step outputs so other action inputs can reference them (multi-line)
            echo "cache_from<<EOF" >> $GITHUB_OUTPUT
            echo "type=gha" >> $GITHUB_OUTPUT
            echo "type=gha,scope=chrome-runner" >> $GITHUB_OUTPUT
            echo "type=gha,scope=buildcache" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cache_to<<EOF" >> $GITHUB_OUTPUT
            echo "type=gha,mode=max,scope=chrome-runner" >> $GITHUB_OUTPUT
            echo "type=gha,mode=max,scope=buildcache" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
      - name: Build and push Chrome runner image
        id: build-chrome
        uses: docker/build-push-action@v6
        with:
          context: ./docker
          platforms: linux/amd64
          file: ./docker/Dockerfile.chrome
          push: true
          load: false
          tags: ${{ steps.meta-chrome.outputs.tags }}
          labels: ${{ steps.meta-chrome.outputs.labels }}
          cache-from: ${{ steps.force-rebuild-chrome.outputs.cache_from }}
          cache-to: ${{ steps.force-rebuild-chrome.outputs.cache_to }}
          no-cache: ${{ steps.force-rebuild-chrome.outputs.force_rebuild == 'true' }}
      - name: Get primary Chrome runner tag for security scan
        id: get-primary-tag-chrome
        if: success() && steps.build-chrome.conclusion == 'success'
        run: |
          TAGS="${{ steps.meta-chrome.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary Chrome runner tag for security scan: $PRIMARY_TAG"
          echo "Chrome runner image pushed to registry: $PRIMARY_TAG"
          echo "$PRIMARY_TAG" > build-chrome-image-tag.txt
          echo "${{ steps.build-chrome.outputs.digest }}" > build-chrome-image-digest.txt
      - name: Upload Chrome build image tag as artifact
        uses: actions/upload-artifact@v5
        with:
          name: build-chrome-image-tag
          path: build-chrome-image-tag.txt
          retention-days: 30
      - name: Upload Chrome build image digest as artifact
        uses: actions/upload-artifact@v5
        with:
          name: build-chrome-image-digest
          path: build-chrome-image-digest.txt
          retention-days: 30
  build-chrome-go:
    name: Build Chrome-Go Runner Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      chrome-go-image-digest: ${{ steps.build-chrome-go.outputs.digest }}
      chrome-go-image-tag: ${{ steps.meta-chrome-go.outputs.tags }}
      chrome-go-image-primary: ${{ steps.get-primary-tag-chrome-go.outputs.primary-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Extract Chrome-Go runner metadata
        id: meta-chrome-go
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_CHROME_GO_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
          labels: |
            org.opencontainers.image.name=github-runner-chrome-go
      - name: Determine Chrome-Go build no-cache
        id: force-rebuild-chrome-go
        run: |
          # Determine whether to force rebuild for the Chrome-Go build
          INPUT_VAL="${{ github.event.inputs.force_rebuild || '' }}"
          HEAD_MSG="${{ github.event.head_commit.message || '' }}"
          echo "event_input=$INPUT_VAL"
          echo "head_commit_message=$HEAD_MSG"
          if [ "$INPUT_VAL" = "true" ] || echo "$HEAD_MSG" | grep -q '\[force rebuild\]'; then
            echo "force_rebuild=true" >> $GITHUB_OUTPUT
            # Clear cache settings so build-push-action won't attempt to import caches
            printf "CACHE_FROM=\nCACHE_TO=\n" >> $GITHUB_ENV
          else
            echo "force_rebuild=false" >> $GITHUB_OUTPUT
            # Provide the default cache sources (multi-line) via GITHUB_ENV
            # Use cross-branch cache to leverage builds from feature branches and other branches
            printf "CACHE_FROM=type=gha\ntype=gha,scope=chrome-go-runner\ntype=gha,scope=buildcache\n" >> $GITHUB_ENV
            printf "CACHE_TO=type=gha,mode=max,scope=chrome-go-runner\ntype=gha,mode=max,scope=buildcache\n" >> $GITHUB_ENV
            # Also emit as step outputs so other action inputs can reference them (multi-line)
            echo "cache_from<<EOF" >> $GITHUB_OUTPUT
            echo "type=gha" >> $GITHUB_OUTPUT
            echo "type=gha,scope=chrome-go-runner" >> $GITHUB_OUTPUT
            echo "type=gha,scope=buildcache" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cache_to<<EOF" >> $GITHUB_OUTPUT
            echo "type=gha,mode=max,scope=chrome-go-runner" >> $GITHUB_OUTPUT
            echo "type=gha,mode=max,scope=buildcache" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
      - name: Build and push Chrome-Go runner image
        id: build-chrome-go
        uses: docker/build-push-action@v6
        with:
          context: ./docker
          platforms: linux/amd64
          file: ./docker/Dockerfile.chrome-go
          push: true
          load: false
          tags: ${{ steps.meta-chrome-go.outputs.tags }}
          labels: ${{ steps.meta-chrome-go.outputs.labels }}
          cache-from: ${{ steps.force-rebuild-chrome-go.outputs.cache_from }}
          cache-to: ${{ steps.force-rebuild-chrome-go.outputs.cache_to }}
          no-cache: ${{ steps.force-rebuild-chrome-go.outputs.force_rebuild == 'true' }}
      - name: Get primary Chrome-Go runner tag for security scan
        id: get-primary-tag-chrome-go
        if: success() && steps.build-chrome-go.conclusion == 'success'
        run: |
          TAGS="${{ steps.meta-chrome-go.outputs.tags }}"
          PRIMARY_TAG=$(echo "$TAGS" | head -n 1)
          echo "primary-tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
          echo "Primary Chrome-Go runner tag for security scan: $PRIMARY_TAG"
          echo "Chrome-Go runner image pushed to registry: $PRIMARY_TAG"
          echo "$PRIMARY_TAG" > build-chrome-go-image-tag.txt
          echo "${{ steps.build-chrome-go.outputs.digest }}" > build-chrome-go-image-digest.txt
      - name: Upload Chrome-Go build image tag as artifact
        uses: actions/upload-artifact@v5
        with:
          name: build-chrome-go-image-tag
          path: build-chrome-go-image-tag.txt
          retention-days: 30
      - name: Upload Chrome-Go build image digest as artifact
        uses: actions/upload-artifact@v5
        with:
          name: build-chrome-go-image-digest
          path: build-chrome-go-image-digest.txt
          retention-days: 30
  # Comprehensive Testing Suite
  test-package-validation:
    name: Package Validation Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Run Package Validation Tests
        run: |
          echo "ðŸ§ª Running comprehensive package validation tests..."
          # Make scripts executable
          chmod +x tests/docker/validate-packages.sh
          chmod +x tests/unit/package-validation.sh
          # Run package validation in dry-run mode first (syntax check)
          echo "Running package validation (dry-run)..."
          DRY_RUN=true tests/docker/validate-packages.sh
          # Run unit tests for package detection
          echo "Running unit tests for obsolete package detection..."
          tests/unit/package-validation.sh
      - name: Upload package validation results
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: package-validation-results
          path: test-results/
          retention-days: 30
  test-comprehensive:
    name: Comprehensive Integration Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          [unit, integration, docker-validation, security, configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Set up test environment
        run: |
          # Install comprehensive test dependencies
          sudo apt-get update
          sudo apt-get install -y jq curl
          # Create test results directory
          mkdir -p test-results/${{ matrix.test-suite }}
          # Make all test scripts executable
          find tests/ -name "*.sh" -type f -exec chmod +x {} \;
      - name: Run Unit Tests
        if: matrix.test-suite == 'unit'
        run: |
          echo "ðŸ§ª Running unit tests..."
          # Run unit tests for package validation
          TEST_RESULTS_DIR="test-results/unit" tests/unit/package-validation.sh
      - name: Run Integration Tests
        if: matrix.test-suite == 'integration'
        run: |
          echo "ðŸ§ª Running integration tests..."
          # Create integration test results directory
          mkdir -p test-results/integration
          # Run focused integration tests for CI environment
          # Skip Docker builds and container tests (tested separately)
          integration_errors=0
          # Test 1: Dockerfile syntax validation
          echo "Validating Dockerfile syntax..."
          # Note: Docker linting is now handled by Super Linter in the main lint-and-validate job
          echo "âœ… Dockerfile validation handled by Super Linter"
          # Test 2: Docker Compose validation
          echo "Validating docker-compose files..."
          # Create temporary directories that compose files expect to exist
          mkdir -p ../cache/build ../cache/deps ../cache/workspace ../config
          mkdir -p docker/test-reports
          for compose_file in docker/docker-compose*.yml; do
            if [[ -f "$compose_file" ]]; then
              compose_name="$(basename "$compose_file")"
              # Set dummy environment variables to avoid warnings during validation
              if GITHUB_TOKEN=dummy GITHUB_REPOSITORY=dummy/repo docker compose -f "$compose_file" config > "test-results/integration/compose-$compose_name.log" 2>&1; then
                echo "âœ… Docker Compose validation passed for $compose_file"
              else
                echo "âŒ Docker Compose validation failed for $compose_file"
                echo "Error details:" 
                cat "test-results/integration/compose-$compose_name.log" | head -20
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done
          # Clean up temporary directories
          rmdir ../cache/build ../cache/deps ../cache/workspace 2>/dev/null || true
          rmdir ../cache 2>/dev/null || true
          rmdir docker/test-reports 2>/dev/null || true
          # Test 3: Configuration file validation
          echo "Validating configuration files..."
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              if [[ "$config_name" != "*.env" ]] && [[ "$config_name" == *.env* ]]; then
                echo "Checking $config_name format..."
                if ! grep -q "=" "$config_file"; then
                  echo "âŒ Configuration file $config_name appears to be empty or invalid"
                  integration_errors=$((integration_errors + 1))
                fi
              fi
            fi
          done
          # Test 4: Script validation
          echo "Validating shell scripts..."
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              if ! bash -n "$script" > "test-results/integration/syntax-$script_name.log" 2>&1; then
                echo "âŒ Syntax error in $script"
                integration_errors=$((integration_errors + 1))
              fi
            fi
          done
          echo "Integration tests completed. Errors: $integration_errors"
          if [[ $integration_errors -gt 0 ]]; then
            echo "âŒ Integration tests failed"
            echo "FAILED" > test-results/integration/status.txt
            exit 1
          else
            echo "âœ… Integration tests passed"
            echo "PASSED" > test-results/integration/status.txt
          fi
      - name: Run Docker Package Validation
        if: matrix.test-suite == 'docker-validation'
        run: |
          echo "ðŸ§ª Running Docker package validation..."
          # Create docker validation test results directory
          mkdir -p test-results/docker-validation
          # Run focused Docker package validation (without building)
          docker_errors=0
          # Test 1: Package duplication check
          echo "Checking for duplicate packages in Dockerfiles..."
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              # Extract package names from RUN commands that install packages
              packages=$(grep -E "RUN.*apt-get install|RUN.*apk add" "$dockerfile" | \
                sed -E 's/.*apt-get install[^a-zA-Z-]*//; s/.*apk add[^a-zA-Z-]*//; s/[\\&|;].*//; s/#.*//; s/\s+/ /g' | \
                tr ' ' '\n' | grep -E '^[a-zA-Z][a-zA-Z0-9.-]*$' | sort)
              # Check for duplicates
              duplicates=$(echo "$packages" | uniq -d)
              if [[ -n "$duplicates" ]]; then
                echo "âŒ Duplicate packages found in $dockerfile_name:"
                echo "$duplicates"
                echo "$duplicates" > "test-results/docker-validation/duplicates-$dockerfile_name.log"
                docker_errors=$((docker_errors + 1))
              else
                echo "âœ… No duplicates in $dockerfile_name"
              fi
            fi
          done
          # Test 2: Obsolete package check
          echo "Checking for known obsolete packages..."
          obsolete_packages=("python2" "python2.7" "python-pip" "nodejs-legacy")
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              for pkg in "${obsolete_packages[@]}"; do
                if grep -q "$pkg" "$dockerfile"; then
                  echo "âŒ Obsolete package '$pkg' found in $dockerfile_name"
                  echo "$pkg" >> "test-results/docker-validation/obsolete-$dockerfile_name.log"
                  docker_errors=$((docker_errors + 1))
                fi
              done
            fi
          done
          echo "Docker validation completed. Errors: $docker_errors"
          if [[ $docker_errors -gt 0 ]]; then
            echo "âŒ Docker package validation failed"
            echo "FAILED" > test-results/docker-validation/status.txt
            exit 1
          else
            echo "âœ… Docker package validation passed"
            echo "PASSED" > test-results/docker-validation/status.txt
          fi
      - name: Run Security Tests
        if: matrix.test-suite == 'security'
        run: |
          echo "ðŸ§ª Running security validation tests..."
          # Create security test results directory
          mkdir -p test-results/security
          # Check for potential secrets
          echo "Checking for potential secrets..."
          secret_patterns=("password" "secret" "token" "key" "api_key" "auth")
          secrets_found=false
          for pattern in "${secret_patterns[@]}"; do
            if grep -r -i "$pattern" . \
                --exclude-dir=".git" \
                --exclude-dir="test-results" \
                --exclude-dir="logs" \
                --exclude="*.log" \
                --exclude="*.md" \
                | grep -v "# Example\|TODO\|FIXME\|template\|placeholder\|test.*$pattern" > "test-results/security/secrets-$pattern.log" 2>&1; then
              echo "âš ï¸  Potential secrets pattern '$pattern' found"
              secrets_found=true
            fi
          done
          # Check Docker security practices
          echo "Checking Docker security practices..."
          security_issues=0
          for dockerfile in docker/Dockerfile*; do
            if [[ -f "$dockerfile" ]]; then
              dockerfile_name="$(basename "$dockerfile")"
              # Check for running as root
              if ! grep -q "USER " "$dockerfile"; then
                echo "SECURITY: $dockerfile_name may run as root" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
              # Check for COPY . .
              if grep -q "COPY \. \." "$dockerfile"; then
                echo "SECURITY: $dockerfile_name uses 'COPY . .' - overly broad" >> "test-results/security/docker-security.log"
                security_issues=$((security_issues + 1))
              fi
            fi
          done
          echo "Security scan completed. Issues found: $security_issues"
          echo "PASSED: $security_issues issues found" > test-results/security/status.txt
      - name: Run Configuration Tests
        if: matrix.test-suite == 'configuration'
        run: |
          echo "ðŸ§ª Running configuration validation tests..."
          # Create configuration test results directory
          mkdir -p test-results/configuration
          config_errors=0
          # Test configuration files
          for config_file in config/*.env*; do
            if [[ -f "$config_file" ]]; then
              config_name="$(basename "$config_file")"
              echo "Validating $config_name..."
              # Syntax check
              if ! bash -n "$config_file" > "test-results/configuration/$config_name.log" 2>&1; then
                echo "âŒ Syntax error in $config_name"
                config_errors=$((config_errors + 1))
              fi
              # Check for required variables
              required_vars=("GITHUB_TOKEN" "GITHUB_REPOSITORY")
              for var in "${required_vars[@]}"; do
                if ! grep -q "^$var\|^#.*$var" "$config_file"; then
                  echo "MISSING: $var not found in $config_name" >> "test-results/configuration/missing-vars.log"
                fi
              done
            fi
          done
          # Test scripts
          for script in scripts/*.sh; do
            if [[ -f "$script" ]]; then
              script_name="$(basename "$script")"
              # Syntax check
              if ! bash -n "$script" > "test-results/configuration/$script_name.log" 2>&1; then
                echo "âŒ Syntax error in $script_name"
                config_errors=$((config_errors + 1))
              fi
            fi
          done
          echo "Configuration validation completed. Errors found: $config_errors"
          if [[ $config_errors -gt 0 ]]; then
            echo "FAILED" > test-results/configuration/status.txt
            exit 1
          else
            echo "PASSED" > test-results/configuration/status.txt
          fi
      - name: Upload comprehensive test results
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: test-results-${{ matrix.test-suite }}
          path: test-results/${{ matrix.test-suite }}
          retention-days: 30
  test-user-deployment:
    name: User Deployment Experience Tests
    runs-on: ubuntu-latest
    needs: [build, build-chrome]
    # Run on either:
    #  - Feature PRs targeting 'develop' (feature -> develop), so we validate user deployment experience early
    #  - Promotion PRs from 'develop' into 'main' (develop -> main), so we validate release promotions
    if: ${{ github.event_name == 'pull_request' && (github.event.pull_request.base.ref == 'develop' || (github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.ref == 'develop')) }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Pull built images from registry
        run: |
          # Pull the images that were just built and pushed by the build jobs
          echo "Pulling main runner image: ${{ needs.build.outputs.normal-image-primary }}"
          docker pull "${{ needs.build.outputs.normal-image-primary }}"
          echo "Pulling Chrome runner image: ${{ needs.build-chrome.outputs.chrome-image-primary }}"
          docker pull "${{ needs.build-chrome.outputs.chrome-image-primary }}"
          echo "Available images for testing:"
          docker images | grep github-runner
      - name: Run User Deployment Experience Tests
        run: |
          chmod +x tests/user-deployment/test-user-experience.sh
          tests/user-deployment/test-user-experience.sh
      - name: Upload user deployment test results
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: user-deployment-test-results
          path: test-results/user-deployment
          retention-days: 30
  # test-container-startup job removed: containers are provisioned by provision-normal-runner and provision-chrome-runner.
  security-container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Run Trivy vulnerability scanner on container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.normal-image-primary }}
          format: "sarif"
          output: "trivy-container-results.sarif"
      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: "trivy-container-results.sarif"
          category: "container-scan"
  security-chrome-scan:
    name: Chrome Container Security Scan
    runs-on: ubuntu-latest
    needs: [build-chrome]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Run Trivy vulnerability scanner on Chrome container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-chrome.outputs.chrome-image-primary }}
          format: "sarif"
          output: "trivy-chrome-results.sarif"
      - name: Upload Chrome container scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: "trivy-chrome-results.sarif"
          category: "chrome-container-scan"
  security-chrome-go-scan:
    name: Chrome-Go Container Security Scan
    runs-on: ubuntu-latest
    needs: [build-chrome-go]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
      - name: Run Trivy vulnerability scanner on Chrome-Go container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-chrome-go.outputs.chrome-go-image-primary }}
          format: "sarif"
          output: "trivy-chrome-go-results.sarif"
      - name: Upload Chrome-Go container scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: "trivy-chrome-go-results.sarif"
          category: "chrome-go-container-scan"
  cleanup:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    needs:
      - provision-normal-runner
      - provision-chrome-runner
      - provision-chrome-go-runner
      - security-container-scan
      - security-chrome-scan
      - security-chrome-go-scan
      - test-comprehensive
    # Always run cleanup, even if provisioning was skipped (e.g., Dependabot)
    if: always()
    permissions:
      contents: read
      packages: write
    steps:
      - name: Clean up old container images
        run: |
          echo "Cleaning up old container images..."
          # In a real scenario, this would clean up old images from the registry
          # For example, keeping only the last 10 images
          echo "Cleanup completed"
      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."
          # Create deployment summary line by line
          echo "# Deployment Report" > deployment-report.md
          echo "" >> deployment-report.md
          echo "## Summary" >> deployment-report.md
          echo "- **Workflow Run ID**: ${{ github.run_id }}" >> deployment-report.md
          echo "- **Commit SHA**: ${{ github.sha }}" >> deployment-report.md
          echo "- **Branch**: ${{ github.ref_name }}" >> deployment-report.md
          echo "- **Triggered by**: ${{ github.actor }}" >> deployment-report.md
          echo "- **Timestamp**: $(date -u)" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Image Details" >> deployment-report.md
          echo "- Registry: ${{ env.REGISTRY }}" >> deployment-report.md
          echo "- Repository: ${{ env.IMAGE_NAME }}" >> deployment-report.md
          echo "- Tags: Built and scanned successfully" >> deployment-report.md
          # Check if file was created
          if [[ ! -f deployment-report.md ]]; then
            echo "ERROR: deployment-report.md not created"
            exit 1
          fi
          cat deployment-report.md
      - name: Upload deployment report
        uses: actions/upload-artifact@v5
        with:
          name: deployment-report
          path: deployment-report.md
          retention-days: 30
